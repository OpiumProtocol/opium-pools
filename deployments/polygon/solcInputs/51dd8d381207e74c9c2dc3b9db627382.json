{
  "language": "Solidity",
  "sources": {
    "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@gnosis.pm/safe-contracts/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/core/Module.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Module Interface - A contract that can pass messages to a Module Manager contract if enabled by that contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"../interfaces/IAvatar.sol\";\nimport \"../factory/FactoryFriendly.sol\";\nimport \"../guard/Guardable.sol\";\n\nabstract contract Module is FactoryFriendly, Guardable {\n    /// @dev Emitted each time the avatar is set.\n    event AvatarSet(address indexed previousAvatar, address indexed newAvatar);\n    /// @dev Emitted each time the Target is set.\n    event TargetSet(address indexed previousTarget, address indexed newTarget);\n\n    /// @dev Address that will ultimately execute function calls.\n    address public avatar;\n    /// @dev Address that this module will pass transactions to.\n    address public target;\n\n    /// @dev Sets the avatar to a new avatar (`newAvatar`).\n    /// @notice Can only be called by the current owner.\n    function setAvatar(address _avatar) public onlyOwner {\n        address previousAvatar = avatar;\n        avatar = _avatar;\n        emit AvatarSet(previousAvatar, _avatar);\n    }\n\n    /// @dev Sets the target to a new target (`newTarget`).\n    /// @notice Can only be called by the current owner.\n    function setTarget(address _target) public onlyOwner {\n        address previousTarget = target;\n        target = _target;\n        emit TargetSet(previousTarget, _target);\n    }\n\n    /// @dev Passes a transaction to be executed by the avatar.\n    /// @notice Can only be called by this contract.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function exec(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (bool success) {\n        /// check if a transactioon guard is enabled.\n        if (guard != address(0)) {\n            IGuard(guard).checkTransaction(\n                /// Transaction info used by module transactions\n                to,\n                value,\n                data,\n                operation,\n                /// Zero out the redundant transaction information only used for Safe multisig transctions\n                0,\n                0,\n                0,\n                address(0),\n                payable(0),\n                bytes(\"0x\"),\n                address(0)\n            );\n        }\n        success = IAvatar(target).execTransactionFromModule(\n            to,\n            value,\n            data,\n            operation\n        );\n        if (guard != address(0)) {\n            IGuard(guard).checkAfterExecution(bytes32(\"0x\"), success);\n        }\n        return success;\n    }\n\n    /// @dev Passes a transaction to be executed by the target and returns data.\n    /// @notice Can only be called by this contract.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execAndReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) internal returns (bool success, bytes memory returnData) {\n        /// check if a transactioon guard is enabled.\n        if (guard != address(0)) {\n            IGuard(guard).checkTransaction(\n                /// Transaction info used by module transactions\n                to,\n                value,\n                data,\n                operation,\n                /// Zero out the redundant transaction information only used for Safe multisig transctions\n                0,\n                0,\n                0,\n                address(0),\n                payable(0),\n                bytes(\"0x\"),\n                address(0)\n            );\n        }\n        (success, returnData) = IAvatar(target)\n            .execTransactionFromModuleReturnData(to, value, data, operation);\n        if (guard != address(0)) {\n            IGuard(guard).checkAfterExecution(bytes32(\"0x\"), success);\n        }\n        return (success, returnData);\n    }\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/factory/FactoryFriendly.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac FactoryFriendly - A contract that allows other contracts to be initializable and pass bytes as arguments to define contract state\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nabstract contract FactoryFriendly is OwnableUpgradeable {\n    function setUp(bytes memory initializeParams) public virtual;\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/guard/BaseGuard.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/interfaces/IERC165.sol\";\nimport \"../interfaces/IGuard.sol\";\n\nabstract contract BaseGuard is IERC165 {\n    function supportsInterface(bytes4 interfaceId)\n        external\n        pure\n        override\n        returns (bool)\n    {\n        return\n            interfaceId == type(IGuard).interfaceId || // 0xe6d7a83a\n            interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\n    }\n\n    /// Module transactions only use the first four parameters: to, value, data, and operation.\n    /// Module.sol hardcodes the remaining parameters as 0 since they are not used for module transactions.\n    /// This interface is used to maintain compatibilty with Gnosis Safe transaction guards.\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external virtual;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external virtual;\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/guard/Guardable.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@gnosis.pm/safe-contracts/contracts/interfaces/IERC165.sol\";\nimport \"./BaseGuard.sol\";\n\n/// @title Guardable - A contract that manages fallback calls made to this contract\ncontract Guardable is OwnableUpgradeable {\n    event ChangedGuard(address guard);\n\n    address public guard;\n\n    /// @dev Set a guard that checks transactions before execution\n    /// @param _guard The address of the guard to be used or the 0 address to disable the guard\n    function setGuard(address _guard) external onlyOwner {\n        if (_guard != address(0)) {\n            require(\n                BaseGuard(_guard).supportsInterface(type(IGuard).interfaceId),\n                \"Guard does not implement IERC165\"\n            );\n        }\n        guard = _guard;\n        emit ChangedGuard(guard);\n    }\n\n    function getGuard() external view returns (address _guard) {\n        return guard;\n    }\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IAvatar {\n    /// @dev Enables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Modules should be stored as a linked list.\n    /// @notice Must emit EnabledModule(address module) if successful.\n    /// @param module Module to be enabled.\n    function enableModule(address module) external;\n\n    /// @dev Disables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Must emit DisabledModule(address module) if successful.\n    /// @param prevModule Address that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) external;\n\n    /// @dev Allows a Module to execute a transaction.\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    /// @dev Allows a Module to execute a transaction and return data\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success, bytes memory returnData);\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) external view returns (bool);\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize)\n        external\n        view\n        returns (address[] memory array, address next);\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/interfaces/IGuard.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IGuard {\n    function checkTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation,\n        uint256 safeTxGas,\n        uint256 baseGas,\n        uint256 gasPrice,\n        address gasToken,\n        address payable refundReceiver,\n        bytes memory signatures,\n        address msgSender\n    ) external;\n\n    function checkAfterExecution(bytes32 txHash, bool success) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = _setInitializedVersion(1);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        bool isTopLevelCall = _setInitializedVersion(version);\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(version);\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        _setInitializedVersion(type(uint8).max);\n    }\n\n    function _setInitializedVersion(uint8 version) private returns (bool) {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n        // of initializers, because in other contexts the contract may have been reentered.\n        if (_initializing) {\n            require(\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\n                \"Initializable: contract is already initialized\"\n            );\n            return false;\n        } else {\n            require(_initialized < version, \"Initializable: contract is already initialized\");\n            _initialized = version;\n            return true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\nimport \"../../../utils/AddressUpgradeable.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20Upgradeable {\n    using AddressUpgradeable for address;\n\n    function safeTransfer(\n        IERC20Upgradeable token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20Upgradeable token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20Upgradeable token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSetUpgradeable {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/base/RegistryManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\nimport \"../interfaces/IRegistryModule.sol\";\n\n/**\n    @notice Abstract contract to allow other modules use Registry Module\n    Error codes:\n        - RM1 = Incorrect input\n */\nabstract contract RegistryManager is ReentrancyGuardUpgradeable, OwnableUpgradeable {\n    event RegistryModuleSet(address indexed previousAddress, address indexed newAddress);\n\n    IRegistryAndZodiacModule internal _registryModule;\n    \n    /// @notice Chained initializer\n    /// @param registryModule_ address / instance of the Registry Module to setup\n    /// @param owner_ address of the RegistryManager's owner\n    function __RegistryManager_init(IRegistryAndZodiacModule registryModule_, address owner_) internal onlyInitializing {\n        // Initialize ReentrancyGuardUpgradable\n        __ReentrancyGuard_init();\n        // Initialize OwnableUpgradable\n        __Ownable_init();\n        // Initialize RegistryManager\n        __RegistryManager_init_unchained(registryModule_, owner_);\n    }\n\n    /// @notice Unchained initializer\n    /// @param registryModule_ address / instance of the Registry Module to setup\n    /// @param owner_ address of the RegistryManager's owner\n    function __RegistryManager_init_unchained(IRegistryAndZodiacModule registryModule_, address owner_) internal onlyInitializing {\n        // Set registry module instance\n        _setRegistryModule(registryModule_);\n        // Transfer ownership\n        transferOwnership(owner_);\n    }\n\n    // External setters\n    /// @notice Returns Registry Module instance\n    function getRegistryModule() external view returns (IRegistryAndZodiacModule) {\n        return _registryModule;\n    }\n\n    /// @notice Changes Registry Module instance\n    /// @param registryModule_ new address / instance of the Registry Module\n    function setRegistryModule(IRegistryAndZodiacModule registryModule_) external onlyOwner {\n        _setRegistryModule(registryModule_);\n    }\n\n    // Private setters\n    /// @dev Private Registry Manager instance setter with input sanitizing\n    /// @param registryModule_ address / instance of the Registry Module to set\n    function _setRegistryModule(IRegistryAndZodiacModule registryModule_) private nonReentrant {\n        // Check if not a zero address\n        require(address(registryModule_) != address(0), \"RM1\");\n        \n        address previousAddress = address(_registryModule);\n        _registryModule = registryModule_;\n        \n        emit RegistryModuleSet(previousAddress, address(_registryModule));\n    }\n}\n"
    },
    "contracts/base/RegistryManagerNonUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"../interfaces/IRegistryModule.sol\";\n\n/**\n    @notice Non upgradeable abstract contract to allow other modules use Registry Module\n    Error codes:\n        - RM1 = Incorrect input\n */\nabstract contract RegistryManagerNonUpgradeable is ReentrancyGuard, Ownable {\n    event RegistryModuleSet(address indexed previousAddress, address indexed newAddress);\n\n    IRegistryAndZodiacModule internal _registryModule;\n\n    /// @notice Constructor\n    /// @param registryModule_ address / instance of the Registry Module to setup\n    /// @param owner_ address of the RegistryManager's owner\n    constructor(IRegistryAndZodiacModule registryModule_, address owner_) {\n        // Set registry module instance\n        _setRegistryModule(registryModule_);\n        // Transfer ownership\n        transferOwnership(owner_);\n    }\n\n    // External setters\n    /// @notice Returns Registry Module instance\n    function getRegistryModule() external view returns (IRegistryAndZodiacModule) {\n        return _registryModule;\n    }\n\n    /// @notice Changes Registry Module instance\n    /// @param registryModule_ new address / instance of the Registry Module\n    function setRegistryModule(IRegistryAndZodiacModule registryModule_) external onlyOwner {\n        _setRegistryModule(registryModule_);\n    }\n\n    // Private setters\n    /// @dev Private Registry Manager instance setter with input sanitizing\n    /// @param registryModule_ address / instance of the Registry Module to set\n    function _setRegistryModule(IRegistryAndZodiacModule registryModule_) private nonReentrant {\n        // Check if not a zero address\n        require(address(registryModule_) != address(0), \"RM1\");\n        \n        address previousAddress = address(_registryModule);\n        _registryModule = registryModule_;\n        \n        emit RegistryModuleSet(previousAddress, address(_registryModule));\n    }\n}\n"
    },
    "contracts/interfaces/IAccountingModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\";\n\ninterface IAccountingModule {\n  event Rebalanced(uint256 totalLiquidityBefore, uint256 profitBeforeFees, uint256 profitFee, uint256 maintenanceFee, uint256 loss);\n  event FeeCollectorSet(address indexed previousFeeCollector, address indexed newFeeCollector);\n  event ImmediateProfitFeeSet(uint256 previousFee, uint256 newFee);\n  event AnnualMaintenanceFeeSet(uint256 previousFee, uint256 newFee);\n\n  function getUnderlying() external view returns (IERC20MetadataUpgradeable);\n  function getTotalLiquidity() external view returns (uint256);\n  function getUtilizedLiquidity() external view returns (uint256);\n  function getAvailableLiquidity() external view returns (uint256);\n  function getLiquidityUtilizationRatio() external view returns (uint256);\n  function getAccumulatedFees() external view returns (uint256);\n  function hasPosition(address position_) external view returns (bool);\n  function getFeeCollector() external view returns (address);\n  function getImmediateProfitFee() external view returns (uint256);\n  function getAnnualMaintenanceFee() external view returns (uint256);\n\n  function changeTotalLiquidity(uint256 amount_, bool add_) external;\n  function changeHoldingPosition(address position_, bool add_) external;\n  function rebalance() external;\n  function collectFees() external;\n  function setFeeCollector(address feeCollector_) external;\n  function setImmediateProfitFee(uint256 immediateProfitFee_) external;\n  function setAnnualMaintenanceFee(uint256 annualMaintenanceFee_) external;\n}\n"
    },
    "contracts/interfaces/IEIP4626.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n * https://eips.ethereum.org/EIPS/eip-4626\n */\ninterface IEIP4626 {\n  // Events\n  event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\n  event Withdraw(address indexed caller, address indexed receiver, address indexed owner, uint256 assets, uint256 shares);\n\n  // View\n  function asset() external view returns (address assetTokenAddress);\n  function totalAssets() external view returns (uint256 totalManagedAssets);\n\n  function convertToShares(uint256 assets) external view returns (uint256 shares);\n  function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n  function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n  function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n  function maxMint(address receiver) external view returns (uint256 maxShares);\n  function previewMint(uint256 shares) external view returns (uint256 assets);\n\n  function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n  function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n  function maxRedeem(address owner) external view returns (uint256 maxShares);\n  function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n  // Actions\n  function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n  function mint(uint256 shares, address receiver) external returns (uint256 assets);\n  function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\n  function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n}\n"
    },
    "contracts/interfaces/ILifecycleModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface ILifecycleModule {\n  event EpochStarted(uint256 indexed epochId, uint256 epochStart);\n\n  function getEpochId() external view returns (uint16);\n  function getCurrentEpochStart() external view returns (uint256);\n  function getCurrentEpochEnd() external view returns (uint256);\n  function getEpochLength() external view returns (uint256);\n  function getStakingPhaseLength() external view returns (uint256);\n  function getTradingPhaseLength() external view returns (uint256);\n  function isStakingPhase() external view returns (bool);\n  function isTradingPhase() external view returns (bool);\n  function isIdlePhase() external view returns (bool);\n  function canDeposit() external view returns (bool);\n  function canWithdraw() external view returns (bool);\n  function canTrade() external view returns (bool);\n  function canRebalance() external view returns (bool);\n\n  function progressEpoch() external;\n}\n"
    },
    "contracts/interfaces/IRegistryModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./IAccountingModule.sol\";\nimport \"./ILifecycleModule.sol\";\n\ninterface IRegistryModule {\n  event RegistryAddressesSet(RegistryAddresses registryAddresses);\n\n  struct RegistryAddresses {\n    IAccountingModule accountingModule;\n    ILifecycleModule lifecycleModule;\n    address stakingModule;\n    address strategyModule;\n  }\n\n  // Getters\n  function getRegistryAddresses() external view returns (RegistryAddresses memory);\n\n  // Setters\n  function setRegistryAddresses(RegistryAddresses memory registryAddresses_) external;\n  function executeOnVault(address target, bytes memory data) external;\n  function executeOnVaultDelegate(address target, bytes memory data) external;\n}\n\ninterface IZodiacModule {\n  function avatar() external view returns (address);\n}\n\ninterface IRegistryAndZodiacModule is IZodiacModule, IRegistryModule {}\n"
    },
    "contracts/interfaces/IStakingModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\nimport { Schedulers } from \"../utils/Schedulers.sol\";\nimport \"./IEIP4626.sol\";\n\n\ninterface IStakingModule is IERC20Upgradeable, IEIP4626 {\n  event ScheduledDeposit(address indexed caller, address indexed owner, uint256 assets);\n  event UnscheduledDeposit(address indexed owner, uint256 assets);\n  event SharesClaimed(address indexed owner, uint256 shares);\n  event ScheduledWithdrawal(address indexed caller, address indexed receiver, address indexed owner, uint256 shares);\n  event UnscheduledWithdrawal(address indexed owner, uint256 shares);\n  event AssetsClaimed(address indexed owner, uint256 assets);\n  event RageQuit(address indexed caller, address indexed receiver, address indexed owner, uint256 shares);\n  event Referral(uint256 indexed id);\n  event ProcessedScheduled(uint256 depositedAssets, uint256 mintedShares, uint256 burntShares, uint256 withdrawnAssets);\n\n  function canDeposit() external view returns (bool);\n  function canWithdraw() external view returns (bool);\n  function getScheduledShares(address receiver) external view returns (uint256 scheduledShares);\n  function getScheduledAssets(address receiver) external view returns (uint256 scheduledAssets);\n\n  function depositRef(uint256 assets, address receiver, uint256 referralId) external returns (uint256 shares);\n  function mintRef(uint256 shares, address receiver, uint256 referralId) external returns (uint256 assets);\n  function scheduleDeposit(uint256 assets, address receiver) external returns (uint256 shares);\n  function scheduleDepositRef(uint256 assets, address receiver, uint256 referralId) external returns (uint256 shares);\n  function unscheduleDeposit(uint256 assets) external;\n  function claimScheduledShares(uint256 shares, bool claimAll) external;\n  function scheduleWithdrawal(uint256 shares, address receiver, address owner) external returns (uint256 assets);\n  function unscheduleWithdrawal(uint256 shares) external;\n  function claimScheduledAssets(uint256 assets, bool claimAll) external;\n  function rageQuit(uint256 shares, address receiver, address owner, address[] calldata tokens) external;\n  function postRebalancing() external;\n\n}\n\ninterface IStakingWrapper is IStakingModule {\n  function scheduledDeposits(address receiver) external view returns (Schedulers.ScheduledDeposit memory);\n  function scheduledWithdrawals(address receiver) external view returns (Schedulers.ScheduledWithdrawal memory);\n}\n"
    },
    "contracts/interfaces/IStrategyModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IStrategyModule {}\n"
    },
    "contracts/mock/UsingRegistryManager.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../base/RegistryManager.sol\";\n\n/**\n    @notice Used to test RegistryManager contract\n */\ncontract UsingRegistryManager is RegistryManager {\n    function initialize(\n        IRegistryAndZodiacModule registryModule_,\n        address owner_\n    ) external initializer {\n        __RegistryManager_init(registryModule_, owner_);\n    }\n}\n"
    },
    "contracts/modules/AccountingModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../base/RegistryManager.sol\";\n\nimport \"../interfaces/IAccountingModule.sol\";\n\nimport \"../utils/Selectors.sol\";\n\n/**\n    @notice Accounting Module performs accounting processes for the pool: calculates total and available liquidity, fees, tracks held positions and participates in Rebalancing process\n    Error cores:\n        - AM1 = Only StakingModule allowed\n        - AM2 = Only StrategyModule allowed\n        - AM3 = Wrong input\n        - AM4 = Only fee collector allowed\n        - AM5 = Not ready for rebalancing\n        - AM6 = Only fee collector or executor allowed\n */\ncontract AccountingModule is IAccountingModule, RegistryManager {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /// @notice Reference value (basis) representing 100%\n    uint256 constant public BASE = 1e18;\n    /// @notice Seconds in year stored\n    uint256 constant public YEAR_SECONDS = 360 days;\n\n    // Fees\n    /// @notice Profit fee value\n    uint256 private _immediateProfitFee;\n    /// @notice Annual maintenance fee value\n    uint256 private _annualMaintenanceFee;\n    /// @notice Address of the fees collector\n    address private _feeCollector;\n\n    // Accounting\n    /// @notice Instance of an underlying ERC20 asset\n    IERC20MetadataUpgradeable private _underlying;\n    /// @notice Holds the amount of total liquidity that was available during Rebalancing (Staking phase)\n    uint256 private _totalLiquidity;\n    /// @notice Hold the amount of fees accrued by the system\n    uint256 private _accumulatedFees;\n    /// @notice Holds the record of all the positions that are currently being held by the Vault\n    EnumerableSetUpgradeable.AddressSet private _holdingPositions;\n\n    /// @notice Initializer of the Accounting Module\n    /// @param underlying_ instance of an underlying ERC20 token\n    /// @param registryModule_ instance of a Registry Module to connect to\n    /// @param owner_ address of the contract owner\n    function initialize(\n        IERC20MetadataUpgradeable underlying_,\n        IRegistryAndZodiacModule registryModule_,\n        address owner_\n    )\n        external initializer\n    {\n        // Initialize Registry Manager\n        __RegistryManager_init(registryModule_, owner_);\n        // Set underlying asset\n        _setUnderlying(underlying_);\n        // Set default immediate profit fee to 10%\n        _setImmediateProfitFee(0.1e18);\n        // Set default annual maintenance fee to 2%\n        _setAnnualMaintenanceFee(0.02e18);\n    }\n\n    /// @notice Restricts access to function to Staking Module only\n    modifier onlyStakingModule() {\n        require(\n            (\n                msg.sender == _registryModule\n                    .getRegistryAddresses()\n                    .stakingModule\n            ),\n            \"AM1\"\n        );\n        _;\n    }\n\n    /// @notice Restricts access to function to Strategy Module only\n    modifier onlyStrategyModule() {\n        require(\n            (\n                msg.sender == _registryModule\n                    .getRegistryAddresses()\n                    .strategyModule\n            ),\n            \"AM2\"\n        );\n        _;\n    }\n\n    /// @notice Restricts access to function to Fee Collector only\n    modifier onlyFeeCollector() {\n        require(msg.sender == _feeCollector, \"AM4\");\n        _;\n    }\n\n    /// @notice Restricts access to function to Fee Collector or Owner only\n    modifier onlyFeeCollectorOrOwner() {\n        require(\n            (\n                msg.sender == _feeCollector ||\n                msg.sender == owner()\n            ),\n            \"AM6\"\n        );\n        _;\n    }\n\n    // External getters\n    /// @notice Returns an underlying ERC20 asset instance\n    function getUnderlying() override external view returns (IERC20MetadataUpgradeable) {\n        return _underlying;\n    }\n\n    /// @notice Returns the amount of total liquidity available during Rebalancing (Staking phase)\n    function getTotalLiquidity() override external view returns (uint256) {\n        return _totalLiquidity;\n    }\n\n    /// @notice Returns the amount of currently utilized liquidity\n    function getUtilizedLiquidity() override public view returns (uint256) {\n        // Get the available liquidity\n        uint256 availableLiquidity = getAvailableLiquidity();\n\n        // If available liquidity is greater than total liquidity, then utilization is 0, we have a surplus here\n        if (_totalLiquidity < availableLiquidity) {\n            return 0;\n        }\n\n        // Otherwise return the difference between total liquidity and available liquidity\n        return _totalLiquidity - availableLiquidity;\n    }\n\n    /// @notice Returns currently available liquidity in the Vault\n    function getAvailableLiquidity() override public view returns (uint256) {\n        // Get the current underlying balance of the Vault\n        uint256 poolBalance = _underlying.balanceOf(_registryModule.avatar());\n\n        // Check that Vault balance is greater than accumulated fees to mitigate underflow errors\n        if (poolBalance < _accumulatedFees) {\n            return 0;\n        }\n\n        // Subtract accumulated frees from the Vault's balance\n        return  poolBalance - _accumulatedFees;\n    }\n\n    /// @notice Returns current pool's utilization ratio in % denominated in 1e18\n    function getLiquidityUtilizationRatio() override external view returns (uint256) {\n        // If total liquidity is 0, then utilization is also 0\n        if (_totalLiquidity == 0) {\n            return 0;\n        }\n\n        // utilization ratio = utilized liquidity / total liquidity\n        return getUtilizedLiquidity() * BASE / _totalLiquidity;\n    }\n\n    /// @notice Returns the value of accumulated fees\n    function getAccumulatedFees() override external view returns (uint256) {\n        return _accumulatedFees;\n    }\n\n    /// @notice Returns the fact whether provided position address is being held by the strategy\n    /// @param position_ address of the position\n    function hasPosition(address position_) override external view returns (bool) {\n        return _holdingPositions.contains(position_);\n    }\n\n    /// @notice Returns the address of the Fee Collector\n    function getFeeCollector() override external view returns (address) {\n        return _feeCollector;\n    }\n\n    /// @notice Returns the value of the immediate profit fee\n    function getImmediateProfitFee() override external view returns (uint256) {\n        return _immediateProfitFee;\n    }\n\n    /// @notice Returns the value of the annual maintenance fee\n    function getAnnualMaintenanceFee() override external view returns (uint256) {\n        return _annualMaintenanceFee;\n    }\n\n    // External setters\n    /// @notice Changes the total liquidity amount when asked by Staking Module\n    /// @param amount_ amount to increment or decrement\n    /// @param add_ flag telling whether `amount_` should be added or subtracted from the total liquidity\n    function changeTotalLiquidity(uint256 amount_, bool add_) override external onlyStakingModule {\n        if (add_) {\n            _setTotalLiquidity(_totalLiquidity + amount_);\n        } else {\n            _setTotalLiquidity(_totalLiquidity - amount_);\n        }\n    }\n\n    /// @notice Changes the holding position when asked by Strategy Module\n    /// @param position_ address of the position to add or remove\n    /// @param add_ flag telling whether `position_` should be added or removed from the holding positions\n    function changeHoldingPosition(address position_, bool add_) override external onlyStrategyModule {\n        if (add_) {\n            _holdingPositions.add(position_);\n        } else {\n            _holdingPositions.remove(position_);\n        }\n    }\n\n    /// @notice Performs the accounting when asked by the Strategy Module\n    function rebalance() override external onlyStrategyModule {\n        // Check whether strategy got rid of all the positions before initializing the rebalancing\n        require(_holdingPositions.length() == 0, \"AM5\");\n\n        // Calculate the balance at the beginning of the epoch by adding\n        // previous balance = total liquidity + accumulated fees\n        uint256 previousBalance = _totalLiquidity + _accumulatedFees;\n        // Calculate current balance of the Vault\n        uint256 currentBalance = _underlying.balanceOf(_registryModule.avatar());\n\n        // If current balance is greater than the previous balance, then pool has made profit in the current epoch and the system need to subtract fees\n        if (currentBalance > previousBalance) {\n            // Calculate the gained profit\n            uint256 profitBeforeFees = currentBalance - previousBalance;\n            // Calculate immediate profit fee\n            uint256 profitFee = profitBeforeFees * _immediateProfitFee / BASE;\n            // Subtract profit fee from the profit\n            uint256 profit = profitBeforeFees - profitFee;\n            // Calculate portion of the annual maintenance fee based on the epoch length\n            // maintenance fee = total liquidity * annual maintenance fee * epoch length / year length\n            uint256 maintenanceFee = \n                _totalLiquidity\n                    * _annualMaintenanceFee\n                    * _registryModule.getRegistryAddresses().lifecycleModule.getEpochLength()\n                    / YEAR_SECONDS\n                    / BASE;\n            // Set new accumulated fees\n            _setAccumulatedFees(_accumulatedFees + profitFee + maintenanceFee);\n            uint256 totalLiquidityBefore = _totalLiquidity;\n            // Set new total liquidity\n            _setTotalLiquidity(_totalLiquidity + profit - maintenanceFee);\n\n            emit Rebalanced(totalLiquidityBefore, profitBeforeFees, profitFee, maintenanceFee, 0);\n        } else {\n            // If current balance is less than or equal to previous one, then poll did not make any profit\n            // Calculate the loss\n            uint256 loss = previousBalance - currentBalance;\n            uint256 totalLiquidityBefore = _totalLiquidity;\n            // Set new total liquidity\n            _setTotalLiquidity(_totalLiquidity - loss);\n\n            emit Rebalanced(totalLiquidityBefore, 0, 0, 0, loss);\n        }\n\n        // Trigger Lifecycle Module to progress epoch and perform its internal logic\n        _registryModule.getRegistryAddresses().lifecycleModule.progressEpoch();\n    }\n\n    /// @notice Claims all the accumulated fees when asked by Fee Collector\n    function collectFees() override external onlyFeeCollector {\n        // Cache accumulated fees\n        uint256 accumulatedFees = _accumulatedFees;\n        // Set accumulated fees to zero\n        _setAccumulatedFees(0);\n        // Transfer fees out\n        bytes memory data = abi.encodeWithSelector(Selectors.ERC20_TRANSFER, msg.sender, accumulatedFees);\n        _registryModule.executeOnVault(address(_underlying), data);\n    }\n\n    /// @notice Sets the new fee collector address when asked by current Fee Collector or Owner\n    /// @param feeCollector_ new Fee Collector address\n    function setFeeCollector(address feeCollector_) override external onlyFeeCollectorOrOwner {\n        _setFeeCollector(feeCollector_);\n    }\n\n    /// @notice Sets new immediate profit fee when asked by Owner\n    /// @param immediateProfitFee_ new value of the immediate profit fee\n    function setImmediateProfitFee(uint256 immediateProfitFee_) override external onlyOwner {\n        _setImmediateProfitFee(immediateProfitFee_);\n    }\n\n    /// @notice Sets new annual maintenance fee when asked by Owner\n    /// @param annualMaintenanceFee_ new value of the annual maintenance fee\n    function setAnnualMaintenanceFee(uint256 annualMaintenanceFee_) override external onlyOwner {\n        _setAnnualMaintenanceFee(annualMaintenanceFee_);\n    }\n\n    // Private setters\n    /// @dev Private setter of underlying ERC20 instance with input sanitizing\n    /// @param underlying_ new instance of the underlying asset to set\n    function _setUnderlying(IERC20MetadataUpgradeable underlying_) private {\n        // Check if not a zero address\n        require(address(underlying_) != address(0), \"AM3\");\n        _underlying = underlying_;\n    }\n\n    /// @dev Private setter of total liquidity\n    /// @param totalLiquidity_ new total liquidity\n    function _setTotalLiquidity(uint256 totalLiquidity_) private {\n        _totalLiquidity = totalLiquidity_;\n    }\n    \n    /// @dev Private setter of accumulated fees\n    /// @param accumulatedFees_ new accumulated fees\n    function _setAccumulatedFees(uint256 accumulatedFees_) private {\n        _accumulatedFees = accumulatedFees_;\n    }\n\n    /// @dev Private setter of Fee Collector address\n    /// @param feeCollector_ new Fee Collector address\n    function _setFeeCollector(address feeCollector_) private {\n        address previousFeeCollector = _feeCollector;\n        _feeCollector = feeCollector_;\n        emit FeeCollectorSet(previousFeeCollector, _feeCollector);\n    }\n\n    /// @dev Private setter of immediate profit fee\n    /// @param immediateProfitFee_ new immediate profit fee\n    function _setImmediateProfitFee(uint256 immediateProfitFee_) private {\n        uint256 previousFee = _immediateProfitFee;\n        _immediateProfitFee = immediateProfitFee_;\n        emit ImmediateProfitFeeSet(previousFee, _immediateProfitFee);\n    }\n\n    /// @dev Private setter of annual maintenance fee\n    /// @param annualMaintenanceFee_ new annual maintenance fee\n    function _setAnnualMaintenanceFee(uint256 annualMaintenanceFee_) private {\n        uint256 previousFee = _annualMaintenanceFee;\n        _annualMaintenanceFee = annualMaintenanceFee_;\n        emit AnnualMaintenanceFeeSet(previousFee, _annualMaintenanceFee);\n    }\n}\n"
    },
    "contracts/modules/LifecycleModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../base/RegistryManager.sol\";\n\nimport \"../interfaces/ILifecycleModule.sol\";\nimport \"../interfaces/IStakingModule.sol\";\n\n/**\n    @notice Lifecycle Module performs lifecycle processes for the pool:\n        - keeps track of current epoch\n        - keeps track of current phase\n        - keeps track of currently allowed actions\n        - progresses pool to new epoch\n    \n    Error cores:\n        - LM1 - Only AccountingModule allowed\n        - LM2 - Can not rebalance yet\n        - LM3 - Epoch length is wrong\n */\ncontract LifecycleModule is ILifecycleModule, RegistryManager {\n    /// @notice 10 second buffer for phases to double check and prevent timestamp manipulations as an additional security measure\n    uint256 public constant TIME_DELTA = 10;\n\n    /// @notice Holds the value of the current epoch id (number)\n    uint16 private _epochId;\n    /// @notice Hold the value of the epoch length\n    uint256 private _epochLength;\n    /// @notice Hold the value of the Staking Phase length\n    uint256 private _stakingPhaseLength;\n    /// @notice Holds the value of the Trading Phase length\n    uint256 private _tradingPhaseLength;\n    /// @notice Holds the timestamp when the current epoch started\n    uint256 private _currentEpochStart;\n\n    /// @notice Initializer of the Lifecycle Module\n    /// @param currentEpochStart_ timestamp of the start of the first epoch\n    /// @param lengths_ an array containing epoch, staking phase and trading phase lengths in seconds\n    /// @param registryModule_ instance of a Registry Module to connect to\n    /// @param owner_ address of the contract owner\n    function initialize(\n        uint256 currentEpochStart_,\n        uint256[3] memory lengths_,\n        IRegistryAndZodiacModule registryModule_,\n        address owner_\n    )\n        external initializer\n    {\n        // Initialize Registry Manager\n        __RegistryManager_init(registryModule_, owner_);\n        // Set current epoch start\n        _setCurrentEpochStart(currentEpochStart_);\n        // Set lengths\n        _setLengths(lengths_);\n\n        emit EpochStarted(0, _currentEpochStart);\n    }\n\n    /// @notice Restricts access to function to Accounting Module only\n    modifier onlyAccountingModule() {\n        require(\n            msg.sender == address(\n                _registryModule\n                    .getRegistryAddresses()\n                    .accountingModule\n            ),\n            \"LM1\"\n        );\n        _;\n    }\n\n    // External getters\n    /// @notice Returns current epoch ID (number)\n    function getEpochId() override external view returns (uint16) {\n        return _epochId;\n    }\n\n    /// @notice Returns the timestamp of the current epoch start\n    function getCurrentEpochStart() override external view returns (uint256) {\n        return _currentEpochStart;\n    }\n\n    /// @notice Returns the timestamp of the current epoch end\n    function getCurrentEpochEnd() override external view returns (uint256) {\n        // current epoch end = current epoch start + epoch length\n        return _currentEpochStart + _epochLength;\n    }\n\n    /// @notice Returns the length of the epoch\n    function getEpochLength() override external view returns (uint256) {\n        return _epochLength;\n    }\n\n    /// @notice Returns the length of the Staking Phase\n    function getStakingPhaseLength() override external view returns (uint256) {\n        return _stakingPhaseLength;\n    }\n\n    /// @notice Returns the length of the Trading Phase\n    function getTradingPhaseLength() override external view returns (uint256) {\n        return _tradingPhaseLength;\n    }\n\n    /// @notice Flags whether current phase is Staking Phase\n    function isStakingPhase() override public view returns (bool) {\n        // Check if STAKING phase is active\n        // current epoch start + TIME_DELTA < now < current epoch start + staking phase length - TIME_DELTA\n        return \n            (_currentEpochStart + TIME_DELTA < block.timestamp) &&\n            (block.timestamp < _currentEpochStart + _stakingPhaseLength - TIME_DELTA);\n    }\n\n    /// @notice Flags whether current phase is Trading Phase\n    function isTradingPhase() override public view returns (bool) {\n        // Check if TRADING phase is active\n        // current epoch start + staking phase length + TIME_DELTA < now < current epoch start + staking phase length + trading phase length - TIME_DELTA\n        return\n            (_currentEpochStart + _stakingPhaseLength + TIME_DELTA < block.timestamp) &&\n            (block.timestamp < _currentEpochStart + _stakingPhaseLength + _tradingPhaseLength - TIME_DELTA);\n    }\n\n    /// @notice Flags whether current phase is Idle Phase\n    function isIdlePhase() override public view returns (bool) {\n        // Check if IDLE phase is active\n        // current epoch start + staking phase length + trading phase length + TIME_DELTA < now\n        return _currentEpochStart + _stakingPhaseLength + _tradingPhaseLength + TIME_DELTA < block.timestamp;\n    }\n\n    /// @notice Flags whether deposits are available right now\n    function canDeposit() override external view returns (bool) {\n        return isStakingPhase() || isTradingPhase();\n    }\n\n    /// @notice Flags whether withdrawals are available right now\n    function canWithdraw() override external view returns (bool) {\n        return isStakingPhase();\n    }\n\n    /// @notice Flags whether trading is available right now\n    function canTrade() override external view returns (bool) {\n        return isTradingPhase();\n    }\n\n    // Public getters\n    /// @notice Flags whether the start of the Rebalancing process is possible right now\n    function canRebalance() override public view returns (bool) {\n        return isIdlePhase() && block.timestamp > _currentEpochStart + _epochLength;\n    }\n\n    // External setters\n    /// @notice Performs the epoch progressing when asked by the Accounting Module\n    function progressEpoch() override external onlyAccountingModule {\n        // Check if rebalancing is possible\n        require(canRebalance(), \"LM2\");\n        // Set new epoch start\n        _setCurrentEpochStart(_currentEpochStart + _epochLength);\n        // Increment epoch ID (number)\n        _epochId++;\n\n        emit EpochStarted(_epochId, _currentEpochStart);\n\n        // Trigger post rebalancing function on Staking Module\n        IStakingModule(_registryModule.getRegistryAddresses().stakingModule).postRebalancing();\n    }\n\n    // Private setters\n    /// @dev Private setter of lengths\n    /// @param lengths_ an array containing epoch, staking phase and trading phase lengths in seconds\n    function _setLengths(uint256[3] memory lengths_) private {\n        // Initialize epoch and phases lengths\n        _epochLength = lengths_[0];\n        _stakingPhaseLength = lengths_[1];\n        _tradingPhaseLength = lengths_[2];\n\n        // Validate epoch and phases lengths\n        // STAKING_PHASE + TRADING_PHASE < EPOCH: epoch length should be longer than sum of staking and trading phase lengths\n        // The rest is considered as an IDLE phase\n        require(_stakingPhaseLength + _tradingPhaseLength < _epochLength, \"LM3\");\n        // STAKING_PHASE > TIME_DELTA * 2\n        require(_stakingPhaseLength > TIME_DELTA * 2, \"LM3\");\n        // TRADING_PHASE > TIME_DELTA * 2\n        require(_tradingPhaseLength > TIME_DELTA * 2, \"LM3\");\n    }\n\n    /// @dev Private setter of current epoch start\n    /// @param currentEpochStart_ new epoch start value\n    function _setCurrentEpochStart(uint256 currentEpochStart_) private {\n        _currentEpochStart = currentEpochStart_;\n    }\n}\n"
    },
    "contracts/modules/RegistryModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@gnosis.pm/zodiac/contracts/core/Module.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\";\n\nimport \"../interfaces/IRegistryModule.sol\";\n\n/**\n    @notice Registry Module keeps track of all the other modules connected to the pool's system\n\n    Inherits Zodiac Module contract to be compatible with Zodiac's ecosystem\n\n    Error codes:\n        - R1 = Owner can not be zero address\n        - R2 = Avatar can not be zero address\n        - R3 = Target can not be zero address\n        - R4 = Unauthorized attempt on Vault transactions execution\n        - R5 = Vault transaction execution failed\n        - R6 = Incorrect input\n */\ncontract RegistryModule is IRegistryModule, Module {\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\n\n    /// @notice Holds the address book of the Registry Module\n    RegistryAddresses private _registryAddresses;\n\n    /// @notice Initializer of the Registry Module\n    /// @param initParams encoded arguments (owner address, avatar address, target address)\n    function setUp(bytes memory initParams) public override initializer {\n        // Decode arguments\n        (\n            address _owner,\n            address _avatar,\n            address _target\n        ) = abi.decode(\n            initParams,\n            (address, address, address)\n        );\n        // Initialize OwnableUpgradable\n        __Ownable_init();\n        // Check owner address is not zero address\n        require(_owner != address(0), \"R1\");\n        // Check avatar address is not zero address\n        require(_avatar != address(0), \"R2\");\n        // Check target address is not zero address\n        require(_target != address(0), \"R3\");\n        // Set avatar and target addresses\n        avatar = _avatar;\n        target = _target;\n        // Transfer ownership to the owner\n        transferOwnership(_owner);\n    }\n\n    // External getters\n    /// @notice Returns the address book of the Registry Module\n    function getRegistryAddresses() override external view returns (RegistryAddresses memory) {\n        return _registryAddresses;\n    }\n\n    // External setters\n    function setRegistryAddresses(RegistryAddresses memory registryAddresses_) override external onlyOwner {\n        _setRegistryAddresses(registryAddresses_);\n    }\n\n    /// @notice Executes arbitrary transaction as a call from the Vault's behalf\n    /// @param target address of the call target\n    /// @param data data of the call\n    function executeOnVault(\n        address target,\n        bytes memory data\n    ) override external {\n        // Check if msg.sender is authorized to execute transactions on Vault\n        require(\n            msg.sender == _registryAddresses.stakingModule ||\n            msg.sender == address(_registryAddresses.accountingModule) ||\n            msg.sender == _registryAddresses.strategyModule,\n            \"R4\"\n        );\n        // Execute via Zodiac's Module\n        bool success = exec(target, 0, data, Enum.Operation.Call);\n        // Check if succeeded\n        require(success, \"R5\");\n    }\n\n    /// @notice Executes arbitrary transaction as a call from the Vault's behalf\n    /// @param target address of the call target\n    /// @param data data of the call\n    function executeOnVaultDelegate(\n        address target,\n        bytes memory data\n    ) override external {\n        // Check if msg.sender is authorized to execute transactions on Vault\n        require(\n            msg.sender == _registryAddresses.stakingModule ||\n            msg.sender == address(_registryAddresses.accountingModule) ||\n            msg.sender == _registryAddresses.strategyModule,\n            \"R4\"\n        );\n        // Execute via Zodiac's Module\n        bool success = exec(target, 0, data, Enum.Operation.DelegateCall);\n        // Check if succeeded\n        require(success, \"R5\");\n    }\n\n    // Private setters\n    /// @dev Private setter of address book of Registry module\n    /// @param registryAddresses_ new address book of Registry module\n    function _setRegistryAddresses(RegistryAddresses memory registryAddresses_) private {\n        // Sanitize inputs and check addresses are non-zero\n        require(\n            (\n                address(registryAddresses_.accountingModule) != address(0) &&\n                address(registryAddresses_.lifecycleModule) != address(0) &&\n                registryAddresses_.stakingModule != address(0) &&\n                registryAddresses_.strategyModule != address(0)\n            ),\n            \"R6\"\n        );\n        // Set new address book\n        _registryAddresses = registryAddresses_;\n        emit RegistryAddressesSet(_registryAddresses);\n    }\n}\n"
    },
    "contracts/modules/StakingModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"../base/RegistryManager.sol\";\n\nimport \"../interfaces/IStakingModule.sol\";\nimport \"../interfaces/ILifecycleModule.sol\";\n\nimport \"../utils/Selectors.sol\";\nimport { FixedPointMathLib } from \"../utils/FixedPointMathLib.sol\";\nimport { Schedulers } from \"../utils/Schedulers.sol\";\n\n/**\n    @notice Staking Module is an ERC20 tokenized position in the pool that follows EIP4626 standard for liquidity provision\n\n    Additionally it allows to schedule deposits and withdrawals if direct ones are not available\n\n    Another Staking Module's feature is Rage Quit, which allows LP token holders to exit the pool any time regardless of the current phase and receive all pools assets in pro-rata basis\n\n    Error codes:\n        - S1 = can't deposit\n        - S2 = can't withdraw\n        - S3 = zero shares on deposit\n        - S4 = zero assets on redemption\n        - S5 = only LifecycleModule allowed\n        - S6 = provided position is not present in an accounting module\n        - S7 = tokens[] is out of order or contains a duplicate\n        - S8 = nothing was scheduled in the current epoch ID (number)\n        - S9 = given amount exceeds available\n */\ncontract StakingModule is IStakingModule, ERC165Upgradeable, ERC20PermitUpgradeable, RegistryManager {\n    using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n    using FixedPointMathLib for uint256;\n    using Schedulers for Schedulers.ScheduledDeposit;\n    using Schedulers for Schedulers.ScheduledWithdrawal;\n\n    /// @notice Holds state of the scheduled deposits by user address\n    mapping(address => Schedulers.ScheduledDeposit) public scheduledDeposits;\n    /// @notice Holds state of the scheduled withdrawals by user address\n    mapping(address => Schedulers.ScheduledWithdrawal) public scheduledWithdrawals;\n    /// @notice Holds share price by epoch ID (number)\n    mapping(uint16 => uint256) public sharePriceByEpoch;\n    /// @notice Holds the total amount of scheduled deposits in the current epoch\n    uint256 public totalScheduledDeposits;\n    /// @notice Holds the total amount of scheduled withdrawals in the current epoch\n    uint256 public totalScheduledWithdrawals;\n\n    /// @notice Initializer of the Staking Module\n    /// @param name_ name of the LP token\n    /// @param symbol_ symbol of the LP token\n    /// @param registryModule_ instance of a Registry Module to connect to\n    /// @param owner_ address of the contract owner\n    function initialize(\n        string memory name_,\n        string memory symbol_,\n        IRegistryAndZodiacModule registryModule_,\n        address owner_\n    )\n        external initializer\n    {\n        // Initialize ERC20PermitUpgradeable\n        __ERC20Permit_init(name_);\n        // Initialize ERC20Upgradeable\n        __ERC20_init(name_, symbol_);\n        // Initialize Registry Manager\n        __RegistryManager_init(registryModule_, owner_);\n    }\n\n    /* MODIFIERS */\n\n    /// @notice Restricts access to function to be callable only when Deposits are available\n    modifier onlyIfCanDeposit() {\n        require(\n            canDeposit(),\n            \"S1\"\n        );\n        _;\n    }\n\n    /// @notice Restricts access to function to be callable only when Withdrawals are available\n    modifier onlyIfCanWithdraw() {\n        require(\n            canWithdraw(),\n            \"S2\"\n        );\n        _;\n    }\n\n    /* PUBLIC */\n\n    /* PUBLIC -> GETTERS */\n\n    /// @notice Indicates whether deposits are available at the moment\n    function canDeposit() override public view returns (bool) {\n        return _registryModule\n            .getRegistryAddresses()\n            .lifecycleModule\n            .canDeposit();\n    }\n\n    /// @notice Indicates whether withdrawals are available at the moment\n    function canWithdraw() override public view returns (bool) {\n        return _registryModule\n            .getRegistryAddresses()\n            .lifecycleModule\n            .canWithdraw();\n    }\n\n    /// @notice See {ERC20Upgradable-decimals}\n    /// @dev Overrides ERC20.decimals to match underlying token's decimals\n    function decimals() override public view returns (uint8) {\n        return _getUnderlying().decimals();\n    }\n\n    /// @notice See {ERC165Upgradable-supportsInterface}\n    /// @dev Overrides ERC165.supportsInterface\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IEIP4626).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /* PUBLIC -> GETTERS -> EIP4626 */\n    /// @notice The address of the underlying token used for the Vault for accounting, depositing, and withdrawing\n    function asset() override external view returns (address assetTokenAddress) {\n        assetTokenAddress = address(_getUnderlying());\n    }\n\n    /// @notice Total amount of the underlying asset that is managed by Vault\n    function totalAssets() override public view returns (uint256 totalManagedAssets) {\n        totalManagedAssets = _registryModule\n            .getRegistryAddresses()\n            .accountingModule\n            .getTotalLiquidity();\n    }\n\n    /// @notice The amount of shares that the Vault would exchange for the amount of assets provided\n    /// @param assets amount of provided assets\n    function convertToShares(uint256 assets) override public view returns (uint256 shares) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n        shares = supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n    }\n\n    /// @notice The amount of assets that the Vault would exchange for the amount of shares provided\n    /// @param shares amount of provided shares\n    function convertToAssets(uint256 shares) override public view returns (uint256 assets) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n        assets = supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n    }\n\n    /// @notice Maximum amount of the underlying asset that can be deposited into the Vault for the receiver, through a deposit call\n    function maxDeposit(address) override external pure returns (uint256 maxAssets) {\n        maxAssets = type(uint256).max;\n    }\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given current on-chain conditions\n    /// @param assets amount of provided assets\n    function previewDeposit(uint256 assets) override public view returns (uint256 shares) {\n        shares = convertToShares(assets);\n    }\n\n    /// @notice Maximum amount of shares that can be minted from the Vault for the receiver, through a mint call\n    function maxMint(address) override external pure returns (uint256 maxShares) {\n        maxShares = type(uint256).max;\n    }\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given current on-chain conditions\n    /// @param shares amount of provided shares\n    function previewMint(uint256 shares) override public view returns (uint256 assets) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n        assets = supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n    }\n\n    /// @notice Maximum amount of the underlying asset that can be withdrawn from the owner balance in the Vault, through a withdraw call\n    /// @param owner address of the LP holder\n    function maxWithdraw(address owner) override external view returns (uint256 maxAssets) {\n        maxAssets = convertToAssets(balanceOf(owner));\n    }\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block, given current on-chain conditions\n    /// @param assets amount of provided assets\n    function previewWithdraw(uint256 assets) override public view returns (uint256 shares) {\n        uint256 supply = totalSupply(); // Saves an extra SLOAD if totalSupply is non-zero.\n        shares = supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n    }\n\n    /// @notice Maximum amount of Vault shares that can be redeemed from the owner balance in the Vault, through a redeem call\n    /// @param owner address of the LP holder\n    function maxRedeem(address owner) override external view returns (uint256 maxShares) {\n        maxShares = balanceOf(owner);\n    }\n\n    /// @notice Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block, given current on-chain conditions\n    /// @param shares amount of provided shares\n    function previewRedeem(uint256 shares) override public view returns (uint256 assets) {\n        assets = convertToAssets(shares);\n    }\n    \n    /// @notice Calculates `receiver`s scheduled shares that are available to claim\n    /// @param receiver address of the LP holder\n    function getScheduledShares(address receiver) override external view returns (uint256 scheduledShares) {\n        // Get the receivers scheduled deposit instance\n        Schedulers.ScheduledDeposit memory scheduledDeposit = scheduledDeposits[receiver];\n        // Calculate the outstanding scheduled shares\n        scheduledShares = scheduledDeposit.processScheduledShares(sharePriceByEpoch, _getEpochId());\n    }\n\n    /// @notice Calculates `receiver`s scheduled assets that are available to claim\n    /// @param receiver address of the LP holder\n    function getScheduledAssets(address receiver) override external view returns (uint256 scheduledAssets) {\n        // Get the receivers scheduled withdrawal instance\n        Schedulers.ScheduledWithdrawal memory scheduledWithdrawal = scheduledWithdrawals[receiver];\n        // Calculate the outstanding scheduled assets\n        scheduledAssets = scheduledWithdrawal.processScheduledAssets(sharePriceByEpoch, _getEpochId());\n    }\n\n    /* PUBLIC -> ACTIONS */\n\n    /// @notice Mints Vault shares to receiver by depositing exactly amount of underlying tokens\n    /// @param assets amount of assets to deposit\n    /// @param receiver address of the shares receiver\n    function deposit(uint256 assets, address receiver) override public onlyIfCanDeposit nonReentrant returns (uint256 shares) {\n        // Check for rounding error since we round down in previewDeposit\n        require((shares = previewDeposit(assets)) != 0, \"S3\");\n        // Transfer tokens in\n        _getUnderlying().safeTransferFrom(msg.sender, _registryModule.avatar(), assets);\n        // Trigger Accounting Module\n        _registryModule.getRegistryAddresses().accountingModule.changeTotalLiquidity(assets, true);\n        // Mint shares\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    /// @notice Performs deposit with a referral link\n    /// @dev see {this.deposit}\n    /// @param referralId unique id of the referral\n    function depositRef(uint256 assets, address receiver, uint256 referralId) override external returns (uint256 shares) {\n        shares = deposit(assets, receiver);\n        emit Referral(referralId);\n    }\n    \n    /// @notice Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens\n    /// @param assets amount of shares to mint\n    /// @param receiver address of the shares receiver\n    function mint(uint256 shares, address receiver) override public onlyIfCanDeposit nonReentrant returns (uint256 assets) {\n        // No need to check for rounding error, previewMint rounds up\n        assets = previewMint(shares);\n        // Transfer tokens in\n        _getUnderlying().safeTransferFrom(msg.sender, _registryModule.avatar(), assets);\n        // Trigger Accounting Module\n        _registryModule.getRegistryAddresses().accountingModule.changeTotalLiquidity(assets, true);\n        // Mint shares\n        _mint(receiver, shares);\n\n        emit Deposit(msg.sender, receiver, assets, shares);\n    }\n\n    /// @notice Performs mint with a referral link\n    /// @dev see {this.mint}\n    /// @param referralId unique id of the referral\n    function mintRef(uint256 shares, address receiver, uint256 referralId) override external returns (uint256 assets) {\n        assets = mint(shares, receiver);\n        emit Referral(referralId);\n    }\n\n    /// @notice Burns shares from owner and sends exactly assets of underlying tokens to receiver\n    /// @param assets amount of assets to withdraw\n    /// @param receiver address of the assets receiver\n    /// @param owner address that owns the shares\n    function withdraw(uint256 assets, address receiver, address owner) override external onlyIfCanWithdraw nonReentrant returns (uint256 shares) {\n        // No need to check for rounding error, previewWithdraw rounds up\n        shares = previewWithdraw(assets);\n        // If sender is not owner of the shares, decrease allowance\n        // If allowance is less than shares, will revert with overflow\n        if (msg.sender != owner) {\n            uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals\n            if (allowed != type(uint256).max) {\n                _approve(owner, msg.sender, allowed - shares);\n            }\n        }\n        // Burn shares\n        _burn(owner, shares);\n        // Trigger Accounting Module\n        _registryModule.getRegistryAddresses().accountingModule.changeTotalLiquidity(assets, false);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        // Transfer tokens out\n        bytes memory data = abi.encodeWithSelector(Selectors.ERC20_TRANSFER, receiver, assets);\n        _registryModule.executeOnVault(address(_getUnderlying()), data);\n    }\n    \n    /// @notice Burns exactly shares from owner and sends assets of underlying tokens to receiver\n    /// @param shares amount of shares to burn\n    /// @param receiver address of the assets receiver\n    /// @param owner address that owns the shares\n    function redeem(uint256 shares, address receiver, address owner) override public onlyIfCanWithdraw nonReentrant returns (uint256 assets) {\n        // If sender is not owner of the shares, decrease allowance\n        // If allowance is less than shares, will revert with overflow\n        if (msg.sender != owner) {\n            uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals\n            if (allowed != type(uint256).max) {\n                _approve(owner, msg.sender, allowed - shares);\n            }\n        }\n        // Check for rounding error since we round down in previewRedeem\n        require((assets = previewRedeem(shares)) != 0, \"S4\");\n        // Burn shares\n        _burn(owner, shares);\n        // Trigger Accounting Module\n        _registryModule.getRegistryAddresses().accountingModule.changeTotalLiquidity(assets, false);\n\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n        // Transfer tokens out\n        bytes memory data = abi.encodeWithSelector(Selectors.ERC20_TRANSFER, receiver, assets);\n        _registryModule.executeOnVault(address(_getUnderlying()), data);\n    }\n\n    /// @notice Deposits users funds directly if possible, otherwise schedules the deposit for the next epoch\n    /// @dev see {this.deposit}\n    function scheduleDeposit(uint256 assets, address receiver) override public nonReentrant returns (uint256 shares) {\n        // Check if can deposit directly\n        if (canDeposit()) {\n            return deposit(assets, receiver);\n        }\n\n        // Get scheduled deposit instance\n        Schedulers.ScheduledDeposit memory scheduledDeposit = scheduledDeposits[receiver];\n\n        // Calculate outstanding shares if any\n        uint256 scheduledShares = scheduledDeposit.processScheduledShares(sharePriceByEpoch, _getEpochId());\n\n        uint256 depositedAssets = assets;\n\n        // If already has scheduled deposit in current epoch, then add already scheduled deposit\n        if (scheduledDeposit.updatedAtEpoch == _getEpochId()) {\n            depositedAssets += scheduledDeposit.depositedAssets;\n        }\n\n        Schedulers.assertUint120(depositedAssets);\n        Schedulers.assertUint120(scheduledShares);\n\n        // Update scheduled deposit\n        scheduledDeposits[receiver] = Schedulers.ScheduledDeposit({\n            updatedAtEpoch: _getEpochId(),\n            depositedAssets: uint120(depositedAssets),\n            scheduledShares: uint120(scheduledShares)\n        });\n\n        // Update total scheduled deposits with assets\n        totalScheduledDeposits += assets;\n\n        // Transfer tokens in\n        _getUnderlying().safeTransferFrom(msg.sender, address(this), assets);\n\n        emit ScheduledDeposit(msg.sender, receiver, assets);\n    }\n\n    /// @notice Performs scheduled deposit with a referral link\n    /// @dev see {this.scheduleDeposit}\n    /// @param referralId unique id of the referral\n    function scheduleDepositRef(uint256 assets, address receiver, uint256 referralId) override external returns (uint256 shares) {\n        shares = scheduleDeposit(assets, receiver);\n        emit Referral(referralId);\n    }\n\n    /// @notice Unschedules the deposit from the next epoch\n    /// @param assets amount of assets to unschedule\n    function unscheduleDeposit(uint256 assets) override external nonReentrant {\n        // Get scheduled deposit instance\n        Schedulers.ScheduledDeposit memory scheduledDeposit = scheduledDeposits[msg.sender];\n\n        // Check if scheduled deposits in the current epoch\n        require(scheduledDeposit.updatedAtEpoch == _getEpochId(), \"S8\");\n\n        // Update scheduled deposit with subtracted assets\n        scheduledDeposits[msg.sender] = Schedulers.ScheduledDeposit({\n            updatedAtEpoch: _getEpochId(),\n            depositedAssets: uint120(scheduledDeposit.depositedAssets - assets),\n            scheduledShares: scheduledDeposit.scheduledShares\n        });\n\n        // Update total scheduled deposits with assets\n        totalScheduledDeposits -= assets;\n\n        // Transfer tokens out\n        _getUnderlying().safeTransfer(msg.sender, assets);\n\n        emit UnscheduledDeposit(msg.sender, assets);\n    }\n\n    /// @notice Claims scheduled shares that were minted for scheduled deposit\n    /// @param shares amount of shares to claim\n    /// @param claimAll indicates whether all available shares should be claimed\n    function claimScheduledShares(uint256 shares, bool claimAll) override external nonReentrant {\n        // Get scheduled deposit instance\n        Schedulers.ScheduledDeposit memory scheduledDeposit = scheduledDeposits[msg.sender];\n\n        // Calculate the outstanding scheduled shares\n        uint256 scheduledShares = scheduledDeposit.processScheduledShares(sharePriceByEpoch, _getEpochId());\n\n        // Check if users wants to claim all shares\n        shares = claimAll ? scheduledShares : shares;\n\n        if (shares == 0) {\n            return;\n        }\n\n        // Check if requested less or equal than available\n        require(shares <= scheduledShares, \"S9\");\n\n        uint256 depositedAssets = scheduledDeposit.depositedAssets;\n\n        // If there is a scheduled deposit on the same epoch, we keep deposited assets untouched\n        // Otherwise erase the field for new deposits\n        if (scheduledDeposit.updatedAtEpoch < _getEpochId()) {\n            depositedAssets = 0;\n        }\n\n        Schedulers.assertUint120(depositedAssets);\n        Schedulers.assertUint120(scheduledShares);\n\n        // Update scheduled deposit with subtracted shares\n        scheduledDeposits[msg.sender] = Schedulers.ScheduledDeposit({\n            updatedAtEpoch: _getEpochId(),\n            depositedAssets: uint120(depositedAssets),\n            scheduledShares: uint120(scheduledShares - shares)\n        });\n\n        // Transfer shares out\n        _transfer(address(this), msg.sender, shares);\n\n        emit SharesClaimed(msg.sender, shares);\n    }\n\n    /// @notice Withdraws users funds directly if possible, otherwise schedules the withdrawal for the next epoch\n    /// @dev See {this.withdraw}\n    function scheduleWithdrawal(uint256 shares, address receiver, address owner) override external nonReentrant returns (uint256 assets) {\n        // Check if can withdraw directly\n        if (canWithdraw()) {\n            return redeem(shares, receiver, owner);\n        }\n\n        // If sender is not owner of the shares, decrease allowance\n        // If allowance is less than shares, will revert with overflow\n        if (msg.sender != owner) {\n            uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals\n            if (allowed != type(uint256).max) {\n                _approve(owner, msg.sender, allowed - shares);\n            }\n        }\n\n        // Update total scheduled withdrawals with shares\n        totalScheduledWithdrawals += shares;\n\n        // Get scheduled withdrawal instance\n        Schedulers.ScheduledWithdrawal memory scheduledWithdrawal = scheduledWithdrawals[receiver];\n\n        // Calculate outstanding assets if any\n        uint256 scheduledAssets = scheduledWithdrawal.processScheduledAssets(sharePriceByEpoch, _getEpochId());\n\n        uint256 withdrawnShares = shares;\n\n        // If already has scheduled withdrawal in current epoch, then add already scheduled withdrawal\n        if (scheduledWithdrawal.updatedAtEpoch == _getEpochId()) {\n            withdrawnShares += scheduledWithdrawal.withdrawnShares;\n        }\n\n        Schedulers.assertUint120(withdrawnShares);\n        Schedulers.assertUint120(scheduledAssets);\n\n        // Update scheduled deposit\n        scheduledWithdrawals[receiver] = Schedulers.ScheduledWithdrawal({\n            updatedAtEpoch: _getEpochId(),\n            withdrawnShares: uint120(withdrawnShares),\n            scheduledAssets: uint120(scheduledAssets)\n        });\n\n        // Transfer shares in\n        _transfer(owner, address(this), shares);\n\n        emit ScheduledWithdrawal(msg.sender, receiver, owner, shares);\n    }\n\n    /// @notice Unschedules the withdrawal from the next epoch\n    /// @param shares amount of shares to unschedule\n    function unscheduleWithdrawal(uint256 shares) override external nonReentrant {\n        // Get scheduled withdrawal instance\n        Schedulers.ScheduledWithdrawal memory scheduledWithdrawal = scheduledWithdrawals[msg.sender];\n\n        // Check if scheduled withdrawals in the current epoch\n        require(scheduledWithdrawal.updatedAtEpoch == _getEpochId(), \"S8\");\n\n        // Update scheduled withdrawal with subtracted shares\n        scheduledWithdrawals[msg.sender] = Schedulers.ScheduledWithdrawal({\n            updatedAtEpoch: _getEpochId(),\n            withdrawnShares: uint120(scheduledWithdrawal.withdrawnShares - shares),\n            scheduledAssets: scheduledWithdrawal.scheduledAssets\n        });\n\n        // Update total scheduled withdrawals with shares\n        totalScheduledWithdrawals -= shares;\n\n        // Transfer shares out\n        _transfer(address(this), msg.sender, shares);\n\n        emit UnscheduledWithdrawal(msg.sender, shares);\n    }\n\n    /// @notice Claims scheduled assets that were allocated for scheduled withdrawal\n    /// @param assets amount of assets to claim\n    /// @param claimAll indicates whether all available assets should be claimed\n    function claimScheduledAssets(uint256 assets, bool claimAll) override external nonReentrant {\n        // Get scheduled withdrawal instance\n        Schedulers.ScheduledWithdrawal memory scheduledWithdrawal = scheduledWithdrawals[msg.sender];\n\n        // Calculate outstanding assets if any\n        uint256 scheduledAssets = scheduledWithdrawal.processScheduledAssets(sharePriceByEpoch, _getEpochId());\n\n        // Check if users wants to claim all assets\n        assets = claimAll ? scheduledAssets : assets;\n\n        if (assets == 0) {\n            return;\n        }\n\n        // Check if requested less or equal than available\n        require(assets <= scheduledAssets, \"S9\");\n\n        uint256 withdrawnShares = scheduledWithdrawal.withdrawnShares;\n        \n        // If there is a scheduled withdrawal on the same epoch, we keep withdrawn shares untouched\n        // Otherwise erase the field for new withdrawals\n        if (scheduledWithdrawal.updatedAtEpoch < _getEpochId()) {\n            withdrawnShares = 0;\n        }\n\n        Schedulers.assertUint120(withdrawnShares);\n        Schedulers.assertUint120(scheduledAssets);\n\n        // Update scheduled withdrawal with subtracted assets\n        scheduledWithdrawals[msg.sender] = Schedulers.ScheduledWithdrawal({\n            updatedAtEpoch: _getEpochId(),\n            withdrawnShares: uint120(withdrawnShares),\n            scheduledAssets: uint120(scheduledAssets - assets)\n        });\n\n        // Transfer tokens out\n        _getUnderlying().safeTransfer(msg.sender, assets);\n\n        emit AssetsClaimed(msg.sender, assets);\n    }\n\n    /// @notice Allows to burn shares and receive the proportion of the given tokens held by the Vault\n    /// @param shares amount of shares to burn\n    /// @param receiver address that will receive the tokens\n    /// @param owner address that owns the shares\n    /// @param tokens array of tokens to receive\n    function rageQuit(uint256 shares, address receiver, address owner, address[] calldata tokens) override external nonReentrant {\n        // If sender is not owner of the shares, decrease allowance\n        // If allowance is less than shares, will revert with overflow\n        if (msg.sender != owner) {\n            uint256 allowed = allowance(owner, msg.sender); // Saves gas for limited approvals\n            if (allowed != type(uint256).max) {\n                _approve(owner, msg.sender, allowed - shares);\n            }\n        }\n\n        // Calculate underlying liquidity that represented shares at the beginning of the epoch\n        uint256 underlingLiquidity = previewRedeem(shares);\n        // Cache total supply before burning\n        uint256 cachedTotalSupply = totalSupply();\n\n        // Burn shares\n        _burn(owner, shares);\n\n        // Trigger Accounting Module\n        _registryModule.getRegistryAddresses().accountingModule.changeTotalLiquidity(underlingLiquidity, false);\n\n        address underlying = address(_getUnderlying());\n        address previousToken;\n        uint256 vaultTokenBalance;\n        uint256 transferAmount;\n        for (uint8 i = 0; i < tokens.length; i++) {\n            // Check if requested token is an underlying or a registered position in Accounting Module\n            require(\n                (\n                    tokens[i] == underlying ||\n                    _registryModule.getRegistryAddresses().accountingModule.hasPosition(tokens[i])\n                ), \"S6\");\n            // Check of there are no duplicates in the tokens array\n            require(\n                tokens[i] > previousToken,\n                \"S7\"\n            );\n            // Get the Vault's balance of the requested token\n            // If requested token is underlying, get the available liquidity from Accounting Module\n            vaultTokenBalance = tokens[i] == underlying\n                ? _registryModule.getRegistryAddresses().accountingModule.getAvailableLiquidity()\n                : IERC20MetadataUpgradeable(tokens[i]).balanceOf(_registryModule.avatar());\n            // Calculate users share of the Vault's balance\n            transferAmount = vaultTokenBalance * shares / cachedTotalSupply;\n\n            // Transfer tokens from vault\n            bytes memory data = abi.encodeWithSelector(Selectors.ERC20_TRANSFER, receiver, transferAmount);\n            _registryModule.executeOnVault(tokens[i], data);\n\n            // Write current token as previous\n            previousToken = tokens[i];\n        }\n\n        emit RageQuit(msg.sender, receiver, owner, shares);\n    }\n\n    /* PRIVATE */\n    /// @notice Performs the minting / burning of shares and transfer of assets required to settle the scheduled deposits and withdrawals\n    function postRebalancing() override external {\n        // Only Lifecycle Module\n        require(\n            msg.sender == address(\n                _registryModule\n                    .getRegistryAddresses()\n                    .lifecycleModule\n            ),\n            \"S5\"\n        );\n\n        // Write new price\n        sharePriceByEpoch[_getEpochId() - 1] = convertToShares(Schedulers.BASE);\n\n        // Calculate amount of shares required to mint to perform scheduled deposits\n        uint256 sharesToMint = previewDeposit(totalScheduledDeposits);\n        // Calculate amount of assets required to transfer to perform scheduled withdrawals\n        uint256 assetsToWithdraw = previewRedeem(totalScheduledWithdrawals);\n\n        // If shares to mint exceeds total shares to withdraw, then we only need to mint new shares, otherwise we only need to burn surplus shares\n        if (sharesToMint > totalScheduledWithdrawals) {\n            _mint(address(this), sharesToMint - totalScheduledWithdrawals);\n        } else {\n            _burn(address(this), totalScheduledWithdrawals - sharesToMint);\n        }\n\n        // Clear total scheduled deposits and withdrawals\n        uint256 depositedAssets = totalScheduledDeposits;\n        uint256 burntShares = totalScheduledWithdrawals;\n        totalScheduledDeposits = 0;\n        totalScheduledWithdrawals = 0;\n\n        // If the total scheduled deposits exceeds assets to withdraw, then we only need to transfer assets to the vault, otherwise we need to transfer assets out of the vault\n        if (depositedAssets > assetsToWithdraw) {\n            // Trigger Accounting Module\n            _registryModule.getRegistryAddresses().accountingModule.changeTotalLiquidity(depositedAssets - assetsToWithdraw, true);\n            // Transfer tokens to vault\n            _getUnderlying().safeTransfer(_registryModule.avatar(), depositedAssets - assetsToWithdraw);\n        } else {\n            // Trigger Accounting Module\n            _registryModule.getRegistryAddresses().accountingModule.changeTotalLiquidity(assetsToWithdraw - depositedAssets, false);\n            // Transfer tokens from vault\n            bytes memory data = abi.encodeWithSelector(Selectors.ERC20_TRANSFER, address(this), assetsToWithdraw - depositedAssets);\n            _registryModule.executeOnVault(address(_getUnderlying()), data);\n        }\n\n        emit ProcessedScheduled(depositedAssets, sharesToMint, burntShares, assetsToWithdraw);\n    }\n\n    /* PRIVATE -> GETTERS */\n    /// @notice Returns and underlying ERC20 asset insance\n    function _getUnderlying() private view returns (IERC20MetadataUpgradeable) {\n        return _registryModule\n            .getRegistryAddresses()\n            .accountingModule\n            .getUnderlying();\n    }\n\n    /// @notice Returns current epoch ID (number)\n    function _getEpochId() private view returns (uint16) {\n        return ILifecycleModule(\n            _registryModule\n                .getRegistryAddresses()\n                .lifecycleModule\n        ).getEpochId();\n    }\n}\n"
    },
    "contracts/modules/Strategies/libraries/AdvisableStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\n\nimport \"./BaseStrategy.sol\";\n\nabstract contract AdvisableStrategy is BaseStrategy, AccessControl {\n  /// @notice Constant containing the hash of the ADVISOR_ROLE\n  bytes32 public constant ADVISOR_ROLE = keccak256(\"ADVISOR_ROLE\");\n\n  constructor(address owner_) {\n    _setupRole(DEFAULT_ADMIN_ROLE, address(owner_));\n  }\n\n  function transferAdvisory(address newAdvisor_) external onlyRole(ADVISOR_ROLE) {\n    _revokeRole(ADVISOR_ROLE, msg.sender);\n    _grantRole(ADVISOR_ROLE, newAdvisor_);\n  }\n}\n"
    },
    "contracts/modules/Strategies/libraries/BaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../../../base/RegistryManagerNonUpgradeable.sol\";\n\n/**\n  @notice BaseStrategy\n  Error cores:\n    - BS1 = Not trading phase\n    - BS2 = Can't rebalance yet\n */\nabstract contract BaseStrategy is RegistryManagerNonUpgradeable {\n  /** MODIFIERS */\n  /// @notice Restricts access to function to be callable only when Trading Phase is active\n  modifier canTrade() {\n    require(\n      _registryModule\n        .getRegistryAddresses()\n        .lifecycleModule\n        .canTrade(),\n        \"BS1\"\n    );\n    _;\n  }\n\n  /// @notice Restricts access to function to be callable only when Rebalancing is available\n  modifier canRebalance() {\n    require(\n      _registryModule\n        .getRegistryAddresses()\n        .lifecycleModule\n        .canRebalance(),\n        \"BS2\"\n    );\n    _;\n  }\n\n  /** EXTERNAL SETTERS */\n  /// @notice Trigger Accounting Module to start rebalancing process only when Rebalancing is possible\n  function rebalance() external canRebalance {\n    _registryModule\n      .getRegistryAddresses()\n      .accountingModule\n      .rebalance();\n  }\n}\n"
    },
    "contracts/modules/Strategies/libraries/external/opium-products/ILiveFeedOracleId.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/// @title Opium.Interface.ILiveFeedOracleId is an interface that every LiveFeed oracleId should implement\ninterface ILiveFeedOracleId {\n    /// @notice \n    /// @param timestamp - Timestamp at which data are needed\n    function _callback(uint256 timestamp) external;\n\n    /// @notice Returns current value of the oracle if possible, or last known value\n    function getResult() external view returns (uint256 result);\n\n    // Event with oracleId metadata JSON string (for Opium derivative explorer)\n    event LogMetadataSet(string metadata);\n}\n"
    },
    "contracts/modules/Strategies/libraries/external/opium-protocol/IOpiumCore.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IOpiumCore {\n  // Opium derivative structure (ticker) definition\n  struct Derivative {\n    // Margin parameter for syntheticId\n    uint256 margin;\n    // Maturity of derivative\n    uint256 endTime;\n    // Additional parameters for syntheticId\n    uint256[] params;\n    // oracleId of derivative\n    address oracleId;\n    // Margin token address of derivative\n    address token;\n    // syntheticId of derivative\n    address syntheticId;\n  }\n  \n  function redeem(address[2] calldata _positionsAddresses, uint256 _amount) external;\n  function execute(address _positionAddress, uint256 _amount) external;\n\n  function createAndMint(\n    Derivative calldata _derivative,\n    uint256 _amount,\n    address[2] calldata _positionsOwners\n  ) external;\n}\n"
    },
    "contracts/modules/Strategies/libraries/external/opium-protocol/IOpiumDerivativeLogic.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./IOpiumCore.sol\";\n\ninterface IOpiumDerivativeLogic {\n  function getMargin(IOpiumCore.Derivative memory _derivative)\n      external\n      view\n      returns (uint256 buyerMargin, uint256 sellerMargin);\n}\n"
    },
    "contracts/modules/Strategies/libraries/external/opium-protocol/IOpiumOnChainPositionsLens.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./IOpiumCore.sol\";\n\ninterface IOpiumOnChainPositionsLens {\n  function predictPositionsAddressesByDerivative(\n    IOpiumCore.Derivative calldata _derivative\n  ) external view returns (address longPositionAddress, address shortPositionAddress);\n}\n"
    },
    "contracts/modules/Strategies/libraries/external/opium-protocol/IOpiumRegistry.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\ninterface IOpiumRegistry {\n  struct ProtocolAddressesArgs {\n    // Address of Opium.Core contract\n    address core;\n    // Address of Opium.OpiumProxyFactory contract\n    address opiumProxyFactory;\n    // Address of Opium.OracleAggregator contract\n    address oracleAggregator;\n    // Address of Opium.SyntheticAggregator contract\n    address syntheticAggregator;\n    // Address of Opium.TokenSpender contract\n    address tokenSpender;\n    // Address of the recipient of execution protocol reserves\n    address protocolExecutionReserveClaimer;\n    // Address of the recipient of redemption protocol reserves\n    address protocolRedemptionReserveClaimer;\n    /// Initially uninitialized variables to allow some flexibility in case of future changes and upgradeability\n    uint32 __gapOne;\n    uint32 __gapTwo;\n  }\n\n  function getProtocolAddresses() external view returns (ProtocolAddressesArgs memory);\n}\n"
    },
    "contracts/modules/Strategies/libraries/external/opium-protocol/LibOpiumCalculator.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nlibrary LibOpiumCalculator {\n  function mulWithPrecisionFactor(uint256 _x, uint256 _y) internal pure returns (uint256) {\n    return (_x * _y) / 1e18;\n  }\n\n  function modWithPrecisionFactor(uint256 _x) internal pure returns (uint256) {\n    return _x % 1e18;\n  }\n}\n"
    },
    "contracts/modules/Strategies/libraries/OpiumAuctionV2EnabledStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"opium-auction-v2/contracts/utils/UsingOpiumAuctionV2.sol\";\n\nimport \"../../../utils/Selectors.sol\";\n\nimport \"./BaseStrategy.sol\";\n\nabstract contract OpiumAuctionV2EnabledStrategy is UsingOpiumAuctionV2, BaseStrategy {\n  address public signMessageLib;\n\n  constructor(address signMessageLib_) {\n    signMessageLib = signMessageLib_;\n  }\n\n  function _startAuction(AuctionOrder memory auctionOrder_) internal {\n    bytes memory encodedOrder = abi.encode(auctionOrder_);\n\n    // Approve sellingAmount to limitOrderProtocol to start auction\n    bytes memory approveCalldata = abi.encodeWithSelector(\n      Selectors.ERC20_APPROVE,\n      limitOrderProtocol,\n      auctionOrder_.sellingAmount\n    );\n    _registryModule.executeOnVault(address(auctionOrder_.sellingToken), approveCalldata);\n\n    // Delegate Call: Sign message\n    bytes memory signMessageCalldata = abi.encodeWithSelector(\n      Selectors.SAFE_SIGN_MESSAGE,\n      encodedOrder\n    );\n    _registryModule.executeOnVaultDelegate(signMessageLib, signMessageCalldata);\n  }\n\n  // TODO: Function: cancel auction\n\n  /**\n    @dev Not used here, because order signature is checked against GnosisSafe\n   */\n  function _isValidOrder(Types.Order memory /** order_ */) internal pure override returns (bool) {\n    return true;\n  }\n}\n"
    },
    "contracts/modules/Strategies/libraries/OpiumProtocolV2EnabledStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"../../../utils/Selectors.sol\";\n\nimport \"./external/opium-protocol/IOpiumRegistry.sol\";\nimport \"./external/opium-protocol/IOpiumCore.sol\";\nimport \"./external/opium-protocol/IOpiumDerivativeLogic.sol\";\nimport \"./external/opium-protocol/LibOpiumCalculator.sol\";\nimport \"./external/opium-protocol/IOpiumOnChainPositionsLens.sol\";\n\nimport \"./BaseStrategy.sol\";\n\nlibrary OpiumSelectors {\n  bytes4 internal constant OPIUM_PROTOCOL_CREATE_AND_MINT = bytes4(keccak256(bytes(\"createAndMint((uint256,uint256,uint256[],address,address,address),uint256,address[2])\")));\n  bytes4 internal constant OPIUM_PROTOCOL_REDEEM = bytes4(keccak256(bytes(\"redeem(address[],uint256)\")));\n  bytes4 internal constant OPIUM_PROTOCOL_EXECUTE = bytes4(keccak256(bytes(\"execute(address,uint256)\")));\n}\n\nabstract contract OpiumProtocolV2EnabledStrategy is BaseStrategy {\n  using LibOpiumCalculator for uint256;\n  using SafeERC20 for IERC20Metadata;\n  \n  /// @notice Reference value (basis) representing 100%\n  uint256 public constant BASE = 1e18;\n\n  /// @notice Instance of the Opium Protocol V2 Registry contract\n  IOpiumRegistry private _opiumRegistry;\n  /// @notice Instance of the Opium Protocol V2 Lens contract\n  IOpiumOnChainPositionsLens private _opiumLens;\n\n  /// @notice Constructor of OpiumProtocolV2EnabledStrategy library\n  /// @param opiumRegistry_ instance of the Opium Protocol V2 Registry contract\n  /// @param opiumLens_ instance of the Opium Protocol V2 Lens contract\n  constructor(\n    IOpiumRegistry opiumRegistry_,\n    IOpiumOnChainPositionsLens opiumLens_\n  ) {\n    // Setup instance of Opium Registry\n    _setOptionRegistry(opiumRegistry_);\n    // Setup instance of Opium Lens\n    _setOpiumLens(opiumLens_);\n  }\n\n  /** Public getters */\n  /// @notice Returns the instance of Opium Protocol V2 Registry\n  function getOpiumRegistry() external view returns (IOpiumRegistry) {\n    return _opiumRegistry;\n  }\n\n  /// @notice Returns the instance of Opium Protocol V2 Lens\n  function getOpiumLens() external view returns (IOpiumOnChainPositionsLens) {\n    return _opiumLens;\n  }\n\n  /** Internal getters */\n\n  /// @notice Calculates the available quantity of the provided derivative to that's possible to mint with the current Vault's liquidity as well as the margin required to be locked within the minting process\n  /// @param derivative_ provided derivative to mint\n  function getAvailableQuantity(IOpiumCore.Derivative memory derivative_) public view returns (uint256 availableQuantity, uint256 requiredMargin) {\n    // Get available liquidity\n    uint256 availableLiquidity = _registryModule.getRegistryAddresses().accountingModule.getAvailableLiquidity();\n    // Get required margin per contract\n    uint256[2] memory margins;\n    (margins[0], margins[1]) = IOpiumDerivativeLogic(derivative_.syntheticId).getMargin(derivative_);\n    // Add LONG and SHORT positions margins together\n    uint256 totalMargin = margins[0] + margins[1];\n\n    // Calculate the available quantity to mint\n    availableQuantity = availableLiquidity * BASE / totalMargin;\n    // Calculate the required margin to mint\n    requiredMargin = availableQuantity * totalMargin / BASE;\n  }\n\n  /** Internal setters */\n  /// @notice Allows advisor to mint the maximum possible quantity of the provided derivative on the Vault's behalf\n  /// @param derivative_ provided derivative to mint\n  function _opiumV2MintPositions(IOpiumCore.Derivative memory derivative_) internal returns (address, address, uint256) {\n    // Get available quantity and required margin\n    (uint256 availableQuantity, uint256 requiredMargin) = getAvailableQuantity(derivative_);\n\n    // Approve margin to TokenSpender to create positions\n    bytes memory data = abi.encodeWithSelector(\n      Selectors.ERC20_APPROVE,\n      _opiumRegistry.getProtocolAddresses().tokenSpender,\n      requiredMargin\n    );\n    _registryModule.executeOnVault(derivative_.token, data);\n\n    // Create positions\n    data = abi.encodeWithSelector(\n      OpiumSelectors.OPIUM_PROTOCOL_CREATE_AND_MINT,\n      derivative_,\n      availableQuantity,\n      [_registryModule.avatar(), _registryModule.avatar()]\n    );\n    _registryModule.executeOnVault(_opiumRegistry.getProtocolAddresses().core, data);\n\n    // Calculate addresses of the LONG and SHORT positions\n    (address longPositionAddress, address shortPositionAddress) = _opiumLens.predictPositionsAddressesByDerivative(derivative_);\n\n    // Get the instance of the Accounting Module\n    IAccountingModule accountingModule = _registryModule.getRegistryAddresses().accountingModule;\n\n    // Notify Accounting Module of the new positions\n    accountingModule.changeHoldingPosition(longPositionAddress, true);\n    accountingModule.changeHoldingPosition(shortPositionAddress, true);\n\n    return (longPositionAddress, shortPositionAddress, availableQuantity);\n  }\n\n  /// @notice Allows to execute all the positions remaining in the Vault when can Rebalance\n  function _opiumV2ExecutePositions(IOpiumCore.Derivative memory derivative_) internal {\n    // Calculate LONG + SHORT positions addresses\n    (address longPositionAddress, address shortPositionAddress) = _opiumLens.predictPositionsAddressesByDerivative(derivative_);\n    // Get the Vault balance of the LONG position\n    uint256 longPositionBalance = IERC20Metadata(longPositionAddress).balanceOf(_registryModule.avatar());\n    // Get the Vault balance of the SHORT position\n    uint256 shortPositionBalance = IERC20Metadata(shortPositionAddress).balanceOf(_registryModule.avatar());\n\n    // Check if positions redemption is possible (meaning Vault holds both LONG and SHORT positions)\n    if (longPositionBalance != 0 && shortPositionBalance != 0) {\n      // Calculate minimum positions for redemption\n      uint256 redeemPositions = longPositionBalance > shortPositionBalance ? shortPositionBalance : longPositionBalance;\n\n      // Redeem positions\n      bytes memory data = abi.encodeWithSelector(OpiumSelectors.OPIUM_PROTOCOL_REDEEM, [longPositionAddress,shortPositionAddress], redeemPositions);\n      _registryModule.executeOnVault(_opiumRegistry.getProtocolAddresses().core, data);\n\n      longPositionBalance -= redeemPositions;\n      shortPositionBalance -= redeemPositions;\n    }\n\n    // If any amount of LONG position remains, execute separately\n    if (longPositionBalance > 0) {\n      bytes memory data = abi.encodeWithSelector(OpiumSelectors.OPIUM_PROTOCOL_EXECUTE, longPositionAddress, longPositionBalance);\n      _registryModule.executeOnVault(_opiumRegistry.getProtocolAddresses().core, data);\n    }\n\n    // If any amount of SHORT position remains, execute separately\n    if (shortPositionBalance > 0) {\n      bytes memory data = abi.encodeWithSelector(OpiumSelectors.OPIUM_PROTOCOL_EXECUTE, shortPositionAddress, shortPositionBalance);\n      _registryModule.executeOnVault(_opiumRegistry.getProtocolAddresses().core, data);\n    }\n\n    // Get Accounting Module instance\n    IAccountingModule accountingModule = _registryModule.getRegistryAddresses().accountingModule;\n\n    // Notify Accounting Module of the cleared positions\n    accountingModule.changeHoldingPosition(longPositionAddress, false);\n    accountingModule.changeHoldingPosition(shortPositionAddress, false);\n  }\n\n  /** Private setters */\n  /// @dev Private setter of Opium Registry\n  /// @param opiumRegistry_ new Opium Registry\n  function _setOptionRegistry(IOpiumRegistry opiumRegistry_) private {\n    _opiumRegistry = opiumRegistry_;\n  }\n\n  /// @dev Private setter of Opium Lens\n  /// @param opiumLens_ new Opium Lens\n  function _setOpiumLens(IOpiumOnChainPositionsLens opiumLens_) private {\n    _opiumLens = opiumLens_;\n  }\n}\n"
    },
    "contracts/modules/Strategies/libraries/OptionCallSellingStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./external/opium-products/ILiveFeedOracleId.sol\";\n\nimport \"./OptionsSellingStrategy.sol\";\n\nabstract contract OptionCallSellingStrategy is OptionsSellingStrategy {\n  // TODO: Implement: Auction selling strategy + Combo\n\n  function getNextStrikePrice() public view override returns (uint256 nextStrikePrice) {\n    uint256 currentPrice = ILiveFeedOracleId(derivative.oracleId).getResult();\n    nextStrikePrice = currentPrice * (BASE + strikePriceDelta) / BASE;\n\n    if (nextStrikePrice > strikePriceRounding) {\n      nextStrikePrice = nextStrikePrice - (nextStrikePrice % strikePriceRounding);\n    }\n  }\n}\n"
    },
    "contracts/modules/Strategies/libraries/OptionPutSellingStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./external/opium-products/ILiveFeedOracleId.sol\";\n\nimport \"./OptionsSellingStrategy.sol\";\n\nabstract contract OptionPutSellingStrategy is OptionsSellingStrategy {\n  function getNextStrikePrice() public view override returns (uint256 nextStrikePrice) {\n    uint256 currentPrice = ILiveFeedOracleId(derivative.oracleId).getResult();\n    nextStrikePrice = currentPrice * (BASE - strikePriceDelta) / BASE;\n\n    if (nextStrikePrice > strikePriceRounding) {\n      nextStrikePrice = nextStrikePrice - (nextStrikePrice % strikePriceRounding);\n    }\n  }\n}\n"
    },
    "contracts/modules/Strategies/libraries/OptionsSellingStrategy.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"./OpiumProtocolV2EnabledStrategy.sol\";\nimport \"./OpiumAuctionV2EnabledStrategy.sol\";\nimport \"./AdvisableStrategy.sol\";\n\nabstract contract OptionsSellingStrategy is OpiumProtocolV2EnabledStrategy, OpiumAuctionV2EnabledStrategy, AdvisableStrategy {\n  IOpiumCore.Derivative public derivative;\n\n  uint256 public strikePriceDeltaLimit;\n\n  uint256 public strikePriceDelta;\n  uint256 public strikePriceRounding;\n\n  uint256 public strikePrice;\n\n  address public longPositionAddress;\n  uint256 public availableQuantity;\n\n  /** Public Getters */\n  function getNextStrikePrice() public virtual returns (uint256);\n\n  /** Public Setters */\n  // Owner\n  function setDerivative(IOpiumCore.Derivative memory derivative_) external onlyOwner {\n    _setDerivative(derivative_);\n  }\n\n  function setStrikePriceDeltaLimit(uint256 strikePriceDeltaLimit_) external onlyOwner {\n    _setStrikePriceDeltaLimit(strikePriceDeltaLimit_);\n  }\n\n  // Advisor\n  function setStrikePriceDelta(uint256 strikePriceDelta_) external onlyRole(ADVISOR_ROLE) {\n    _setStrikePriceDelta(strikePriceDelta_);\n  }\n\n  function setStrikePriceRounding(uint256 strikePriceRounding_) external onlyRole(ADVISOR_ROLE) {\n    _setStrikePriceRounding(strikePriceRounding_);\n  }\n\n  // Anyone\n  function mint() external {\n    require(strikePrice == 0, \"OSS2\");\n\n    strikePrice = getNextStrikePrice();\n    derivative.params[0] = strikePrice;\n    (\n      longPositionAddress,\n      ,\n      availableQuantity\n    ) = _opiumV2MintPositions(derivative);\n  }\n\n  function startAuction() external {\n    require(strikePrice != 0, \"OSS3\");\n\n    uint256 minPrice = 0.0005e18;\n    uint256 maxPrice = 0.0020e18;\n    uint256 duration = 40 minutes;\n\n    ILifecycleModule lifecycleModule = _registryModule.getRegistryAddresses().lifecycleModule;\n\n    uint256[] memory pricingFunctionParams;\n    pricingFunctionParams[0] = 1e18;\n\n    AuctionOrder memory auctionOrder = AuctionOrder(\n      IERC20(longPositionAddress),\n      IERC20(derivative.token),\n      availableQuantity,\n      PricingFunction.EXPONENTIAL,\n      pricingFunctionParams,\n      PricingDirection.DECREASING,\n      true,\n      availableQuantity * minPrice / BASE,\n      availableQuantity * maxPrice / BASE,\n      block.timestamp,\n      block.timestamp + duration,\n      lifecycleModule.getEpochId()\n    );\n\n    _startAuction(auctionOrder);\n  }\n\n  function execute() external {\n    _opiumV2ExecutePositions(derivative);\n\n    strikePrice = 0;\n  }\n\n  /** Internal Getters */\n  function _getNewStrikePrice() internal virtual returns (uint256);\n\n  /** Internal Setters */\n  function _setDerivative(IOpiumCore.Derivative memory derivative_) internal {\n    derivative = derivative_;\n  }\n\n  function _setStrikePriceDeltaLimit(uint256 strikePriceDeltaLimit_) internal {\n    strikePriceDeltaLimit = strikePriceDeltaLimit_;\n  }\n\n  function _setStrikePriceDelta(uint256 strikePriceDelta_) internal {\n    require(strikePriceDelta_ >= strikePriceDeltaLimit, \"OSS1\");\n    strikePriceDelta = strikePriceDelta_;\n  }\n\n  function _setStrikePriceRounding(uint256 strikePriceRounding_) internal {\n    require(strikePriceRounding_ > 0, \"OSS1\");\n    strikePriceRounding = strikePriceRounding_;\n  }\n}\n"
    },
    "contracts/modules/Strategies/TestOptionsSellingStrategyModule.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport \"./libraries/external/opium-protocol/IOpiumRegistry.sol\";\nimport \"./libraries/external/opium-protocol/IOpiumCore.sol\";\nimport \"./libraries/external/opium-protocol/IOpiumDerivativeLogic.sol\";\nimport \"./libraries/external/opium-protocol/LibOpiumCalculator.sol\";\nimport \"./libraries/external/opium-protocol/IOpiumOnChainPositionsLens.sol\";\n\nimport \"../../base/RegistryManager.sol\";\n\nimport \"../../interfaces/IStrategyModule.sol\";\n\nimport \"../../utils/Selectors.sol\";\n\nlibrary OpiumSelectors {\n  bytes4 internal constant OPIUM_PROTOCOL_CREATE_AND_MINT = bytes4(keccak256(bytes(\"createAndMint((uint256,uint256,uint256[],address,address,address),uint256,address[2])\")));\n  bytes4 internal constant OPIUM_PROTOCOL_REDEEM = bytes4(keccak256(bytes(\"redeem(address[],uint256)\")));\n  bytes4 internal constant OPIUM_PROTOCOL_EXECUTE = bytes4(keccak256(bytes(\"execute(address,uint256)\")));\n}\n\n/**\n  @notice TestOptionsSellingStrategyModule allows:\n    - advisors to mint desired derivatives using Vault's assets, set up premiums for minted positions\n    - anyone to purchase desired positions if the premium is set, execute positions when possible and start the rebalancing process\n  Error cores:\n    - OSSM1 = Not trading phase\n    - OSSM2 = Can't rebalance yet\n    - OSSM3 = Wrong derivative end time\n    - OSSM4 = Purchase conditions are not met\n */\ncontract TestOptionsSellingStrategyModule is IStrategyModule, RegistryManager, AccessControlUpgradeable {\n  using LibOpiumCalculator for uint256;\n  using SafeERC20Upgradeable for IERC20MetadataUpgradeable;\n\n  /// @notice Constant containing the hash of the ADVISOR_ROLE\n  bytes32 public constant ADVISOR_ROLE = keccak256(\"ADVISOR_ROLE\");\n  \n  /// @notice Reference value (basis) representing 100%\n  uint256 public constant BASE = 1e18;\n\n  /// @notice Instance of the Opium Protocol V2 Registry contract\n  IOpiumRegistry private _opiumRegistry;\n  /// @notice Instance of the Opium Protocol V2 Lens contract\n  IOpiumOnChainPositionsLens private _opiumLens;\n\n  /// @notice Holds premiums for the positions that are available to be purchased\n  mapping (address => uint256) private _premiums;\n\n  /// @notice Initializer of the Strategy Module\n  /// @param opiumRegistry_ instnace of the Opium Protocol V2 Registry contract\n  /// @param opiumLens_ instance of the Opium Protocol V2 Lens contract\n  /// @param registryModule_ instance of a Registry Module to connect to\n  /// @param owner_ address of the contract owner\n  function initialize(\n    IOpiumRegistry opiumRegistry_,\n    IOpiumOnChainPositionsLens opiumLens_,\n    IRegistryAndZodiacModule registryModule_,\n    address owner_\n  )\n    external initializer\n  {\n    // Initialize Registry Manager\n    __RegistryManager_init(registryModule_, owner_);\n    // Give DEFAULT_ADMIN_ROLE to the owner\n    _setupRole(DEFAULT_ADMIN_ROLE, address(owner_));\n    // Setup instance of Opium Registry\n    _setOptionRegistry(opiumRegistry_);\n    // Setup instance of Opium Lens\n    _setOpiumLens(opiumLens_);\n  }\n\n  /// @notice Restricts access to function to be callable only when Trading Phase is active\n  modifier canTrade() {\n    require(\n      _registryModule\n        .getRegistryAddresses()\n        .lifecycleModule\n        .canTrade(),\n        \"OSSM1\"\n    );\n    _;\n  }\n\n  /// @notice Restricts access to function to be callable only when Rebalancing is available\n  modifier canRebalance() {\n    require(\n      _registryModule\n        .getRegistryAddresses()\n        .lifecycleModule\n        .canRebalance(),\n        \"OSSM2\"\n    );\n    _;\n  }\n\n  // Public getters\n  /// @notice Returns the instance of Opium Protocol V2 Registry\n  function getOpiumRegistry() external view returns (IOpiumRegistry) {\n    return _opiumRegistry;\n  }\n\n  /// @notice Returns the instance of Opium Protocol V2 Lens\n  function getOpiumLens() external view returns (IOpiumOnChainPositionsLens) {\n    return _opiumLens;\n  }\n\n  /// @notice Returns the premium set for the provided position\n  /// @param position_ position to return the premium for\n  function getPremium(address position_) external view returns (uint256) {\n    return _premiums[position_];\n  }\n\n  /// @notice Calculates the available quantity of the provided derivative to that's possible to mint with the current Vault's liquidity as well as the margin required to be locked within the minting process\n  /// @param derivative_ provided derivative to mint\n  function getAvailableQuantity(IOpiumCore.Derivative memory derivative_) public view returns (uint256 availableQuantity, uint256 requiredMargin) {\n    // Get available liquidity\n    uint256 availableLiquidity = _registryModule.getRegistryAddresses().accountingModule.getAvailableLiquidity();\n    // Get required margin per contract\n    uint256[2] memory margins;\n    (margins[0], margins[1]) = IOpiumDerivativeLogic(derivative_.syntheticId).getMargin(derivative_);\n    // Add LONG and SHORT positions margins together\n    uint256 totalMargin = margins[0] + margins[1];\n\n    // Calculate the available quantity to mint\n    availableQuantity = availableLiquidity * BASE / totalMargin;\n    // Calculate the required margin to mint\n    requiredMargin = availableQuantity * totalMargin / BASE;\n  }\n\n  // External setters\n  /// @notice Allows advisor to mint the maximum possible quantity of the provided derivative on the Vault's behalf\n  /// @param derivative_ provided derivative to mint\n  function mintPositions(IOpiumCore.Derivative memory derivative_) external canTrade onlyRole(ADVISOR_ROLE) {\n    // Get the Lifecycle Module instance\n    ILifecycleModule lifecycleModule = _registryModule.getRegistryAddresses().lifecycleModule;\n    // Check that the provided derivative's end time doesn't exceed the current epoch's end\n    require(lifecycleModule.getCurrentEpochEnd() >= derivative_.endTime, \"OSSM3\");\n    // Get available quantity and required margin\n    (uint256 availableQuantity, uint256 requiredMargin) = getAvailableQuantity(derivative_);\n\n    // Approve margin to TokenSpender to create positions\n    bytes memory data = abi.encodeWithSelector(\n      Selectors.ERC20_APPROVE,\n      _opiumRegistry.getProtocolAddresses().tokenSpender,\n      requiredMargin\n    );\n    _registryModule.executeOnVault(derivative_.token, data);\n\n    // Create positions\n    data = abi.encodeWithSelector(\n      OpiumSelectors.OPIUM_PROTOCOL_CREATE_AND_MINT,\n      derivative_,\n      availableQuantity,\n      [_registryModule.avatar(),_registryModule.avatar()]\n    );\n    _registryModule.executeOnVault(_opiumRegistry.getProtocolAddresses().core, data);\n\n    // Calculate addresses of the LONG and SHORT positions\n    (address longPositionAddress, address shortPositionAddress) = _opiumLens.predictPositionsAddressesByDerivative(derivative_);\n\n    // Get the instance of the Accounting Module\n    IAccountingModule accountingModule = _registryModule.getRegistryAddresses().accountingModule;\n\n    // Notify Accounting Module of the new positions\n    accountingModule.changeHoldingPosition(longPositionAddress, true);\n    accountingModule.changeHoldingPosition(shortPositionAddress, true);\n  }\n\n  /// @notice Sets premium for a given position when asked by Advisor\n  /// @param position_ Position to set the premium to\n  /// @param premium_ Premium to set for the given position\n  function setPremium(address position_, uint256 premium_) external onlyRole(ADVISOR_ROLE) {\n    _setPremium(position_, premium_);\n  }\n\n  /// @notice Allows to obtain the provided quantity of the given position from the Vault by paying the required premium\n  /// @param position_ Position to purchase\n  /// @param quantity_ Amount of positions that purchaser is willing to buy\n  /// @param maxPremium_ Maximum premium per position that purchaser is willing to pay\n  function purchasePosition(address position_, uint256 quantity_, uint256 maxPremium_) external canTrade {\n    // Get Accounting Module instance\n    IAccountingModule accountingModule = _registryModule.getRegistryAddresses().accountingModule;\n\n    // Check that the premium for given position was set and doesn't exceed the maximum premium provided by purchaser\n    require(\n      _premiums[position_] != 0 &&\n      _premiums[position_] <= maxPremium_,\n      \"OSSM4\"\n    );\n\n    // Transfer premium in\n    accountingModule.getUnderlying().safeTransferFrom(msg.sender, _registryModule.avatar(), quantity_ * _premiums[position_] / BASE);\n    // Transfer positions out\n    bytes memory data = abi.encodeWithSelector(Selectors.ERC20_TRANSFER, msg.sender, quantity_);\n    _registryModule.executeOnVault(position_, data);\n  }\n\n  /// @notice Allows to execute all the positions remaining in the Vault when can Rebalance\n  function executePositions(IOpiumCore.Derivative memory derivative_) external canRebalance {\n    // Calculate LONG + SHORT positions addresses\n    (address longPositionAddress, address shortPositionAddress) = _opiumLens.predictPositionsAddressesByDerivative(derivative_);\n    // Get the Vault balance of the LONG position\n    uint256 longPositionBalance = IERC20MetadataUpgradeable(longPositionAddress).balanceOf(_registryModule.avatar());\n    // Get the Vault balance of the SHORT position\n    uint256 shortPositionBalance = IERC20MetadataUpgradeable(shortPositionAddress).balanceOf(_registryModule.avatar());\n\n    // Check if positions redemption is possible (meaning Vault holds both LONG and SHORT positions)\n    if (longPositionBalance != 0 && shortPositionBalance != 0) {\n      // Calculate minimum positions for redemption\n      uint256 redeemPositions = longPositionBalance > shortPositionBalance ? shortPositionBalance : longPositionBalance;\n\n      // Redeem positions\n      bytes memory data = abi.encodeWithSelector(OpiumSelectors.OPIUM_PROTOCOL_REDEEM, [longPositionAddress,shortPositionAddress], redeemPositions);\n      _registryModule.executeOnVault(_opiumRegistry.getProtocolAddresses().core, data);\n\n      longPositionBalance -= redeemPositions;\n      shortPositionBalance -= redeemPositions;\n    }\n\n    // If any amount of LONG position remains, execute separately\n    if (longPositionBalance > 0) {\n      bytes memory data = abi.encodeWithSelector(OpiumSelectors.OPIUM_PROTOCOL_EXECUTE, longPositionAddress, longPositionBalance);\n      _registryModule.executeOnVault(_opiumRegistry.getProtocolAddresses().core, data);\n    }\n\n    // If any amount of SHORT position remains, execute separately\n    if (shortPositionBalance > 0) {\n      bytes memory data = abi.encodeWithSelector(OpiumSelectors.OPIUM_PROTOCOL_EXECUTE, shortPositionAddress, shortPositionBalance);\n      _registryModule.executeOnVault(_opiumRegistry.getProtocolAddresses().core, data);\n    }\n\n    // Get Accounting Module instance\n    IAccountingModule accountingModule = _registryModule.getRegistryAddresses().accountingModule;\n\n    // Notify Accounting Module of the cleared positions\n    accountingModule.changeHoldingPosition(longPositionAddress, false);\n    accountingModule.changeHoldingPosition(shortPositionAddress, false);\n  }\n\n  /// @notice Trigger Accounting Module to start rebalancing process only when Rebalancing is possible\n  function rebalance() external canRebalance {\n    _registryModule.getRegistryAddresses().accountingModule.rebalance();\n  }\n\n  // Private setters\n  /// @dev Private setter of Opium Registry\n  /// @param opiumRegistry_ new Opium Registry\n  function _setOptionRegistry(IOpiumRegistry opiumRegistry_) private {\n    _opiumRegistry = opiumRegistry_;\n  }\n\n  /// @dev Private setter of Opium Lens\n  /// @param opiumLens_ new Opium Lens\n  function _setOpiumLens(IOpiumOnChainPositionsLens opiumLens_) private {\n    _opiumLens = opiumLens_;\n  }\n\n  /// @dev Private setter of premium for a given position\n  /// @param position_ position address\n  /// @param premium_ new premium\n  function _setPremium(address position_, uint256 premium_) private {\n    _premiums[position_] = premium_;\n  }\n}\n"
    },
    "contracts/utils/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n    /*//////////////////////////////////////////////////////////////\n                    LOW LEVEL FIXED POINT OPERATIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function mulDivDown(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // Divide z by the denominator.\n            z := div(z, denominator)\n        }\n    }\n\n    function mulDivUp(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 z) {\n        assembly {\n            // Store x * y in z for now.\n            z := mul(x, y)\n\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n                revert(0, 0)\n            }\n\n            // First, divide z - 1 by the denominator and add 1.\n            // We allow z - 1 to underflow if z is 0, because we multiply the\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n        }\n    }\n}\n"
    },
    "contracts/utils/PoolsLens.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IRegistryModule.sol\";\nimport \"../interfaces/IAccountingModule.sol\";\nimport \"../interfaces/IStakingModule.sol\";\nimport \"../interfaces/ILifecycleModule.sol\";\n\n/// @notice Contract for easy fetching pools data\ncontract PoolsLens {\n  struct ModulesDataStruct {\n    address stakingAddress;\n    address accountingAddress;\n    address lifecycleAddress;\n    address vaultAddress;\n    address strategyAddress;\n  }\n\n  /// @notice Returns addresses of modules\n  /// @param _registryAddress address of Registry module\n  function getPoolModules(address _registryAddress) public view returns (ModulesDataStruct memory) {\n    IRegistryAndZodiacModule registryModule = IRegistryAndZodiacModule(_registryAddress);\n    IRegistryAndZodiacModule.RegistryAddresses memory addresses = registryModule.getRegistryAddresses();\n    return ModulesDataStruct(\n      addresses.stakingModule,\n      address(addresses.accountingModule),\n      address(addresses.lifecycleModule),\n      registryModule.avatar(),\n      addresses.strategyModule\n    );\n  }\n\n  struct AccountingDataStruct {\n    uint256 poolSize;\n    uint256 poolUtilization;\n    uint256 managementFee;\n    uint256 performanceFee;\n    uint256 marginDecimals;\n    address marginAddress;\n    string marginTitle;\n  }\n\n  /// @notice Returns usable data from Accounting module\n  /// @param _accountingAddress address of Accounting module\n  function getAccountingData(address _accountingAddress) public view returns (AccountingDataStruct memory) {\n    IAccountingModule accountingModule = IAccountingModule(_accountingAddress);\n    IERC20MetadataUpgradeable token = accountingModule.getUnderlying();\n    return AccountingDataStruct(\n      accountingModule.getTotalLiquidity(),\n      accountingModule.getLiquidityUtilizationRatio(),\n      accountingModule.getAnnualMaintenanceFee(),\n      accountingModule.getImmediateProfitFee(),\n      token.decimals(),\n      address(token),\n      token.symbol()\n    );\n  }\n\n  struct StakingDataStruct {\n    uint256 pendingStake;\n    uint256 pendingWithdrawal;\n    uint256 userStaked;\n    uint256 claimableAssets;\n    uint256 claimableShares;\n    uint256 totalSupply;\n  }\n\n  /// @notice Returns usable data from Staking module\n  /// @param _stakingAddress address of Staking module\n  /// @param _lifecycleAddress address of Staking module\n  /// @param _userAddress address of user\n  function getStakingData(address _stakingAddress, address _lifecycleAddress, address _userAddress) public view returns (StakingDataStruct memory) {\n    IStakingWrapper stakingModule = IStakingWrapper(_stakingAddress);\n    ILifecycleModule lifecycleModule = ILifecycleModule(_lifecycleAddress);\n    \n    uint256 pendingStake = lifecycleModule.getEpochId() == stakingModule.scheduledDeposits(_userAddress).updatedAtEpoch  ? stakingModule.scheduledDeposits(_userAddress).depositedAssets : 0;\n    uint256 pendingWithdrawal = lifecycleModule.getEpochId() == stakingModule.scheduledWithdrawals(_userAddress).updatedAtEpoch  ? stakingModule.scheduledWithdrawals(_userAddress).withdrawnShares : 0;\n    \n    return StakingDataStruct(\n      pendingStake,\n      pendingWithdrawal,\n      stakingModule.balanceOf(_userAddress),\n      stakingModule.getScheduledAssets(_userAddress),\n      stakingModule.getScheduledShares(_userAddress),\n      stakingModule.totalSupply()\n    );\n  }\n\n  struct LifecycleDataStruct {\n    uint256 currentEpochTimestamp;\n    uint256 currentEpochStarted;\n    uint256[3] phasesLength;\n    uint256 epochLength;\n    bool isStakingPhase;\n    bool isTradingPhase;\n    bool isIdlePhase;\n  }\n\n  /// @notice Returns usable data from Lifecycle module\n  /// @param _lifecycleAddress address of Lifecycle module\n  function getLifecycleData(address _lifecycleAddress) public view returns (LifecycleDataStruct memory) {\n    ILifecycleModule lifecycleModule = ILifecycleModule(_lifecycleAddress);\n    return LifecycleDataStruct(\n      lifecycleModule.getCurrentEpochEnd(),\n      lifecycleModule.getCurrentEpochStart(),\n      [\n        lifecycleModule.getStakingPhaseLength(), \n        lifecycleModule.getTradingPhaseLength(), \n        lifecycleModule.getEpochLength() - lifecycleModule.getStakingPhaseLength() - lifecycleModule.getTradingPhaseLength()\n      ],\n      lifecycleModule.getEpochLength(),\n      lifecycleModule.isStakingPhase(),\n      lifecycleModule.isTradingPhase(),\n      lifecycleModule.isIdlePhase()\n    );\n  }\n\n  /// @notice Returns all pool-related and user-based data\n  function getPoolData(address _registryAddress, address _userAddress) external view returns(\n    ModulesDataStruct memory modules,\n    AccountingDataStruct memory accounting,\n    StakingDataStruct memory staking,\n    LifecycleDataStruct memory lifecycle\n  ) {\n    modules = getPoolModules(_registryAddress);\n    accounting = getAccountingData(modules.accountingAddress);\n    staking = getStakingData(modules.stakingAddress, modules.lifecycleAddress, _userAddress);\n    lifecycle = getLifecycleData(modules.lifecycleAddress);\n  }\n}\n"
    },
    "contracts/utils/Schedulers.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\n/**\n    @notice Library with helpers for Schedulers\n\n    Error codes:\n        - SCH1 = overflow uint120\n */\nlibrary Schedulers {\n    uint256 internal constant BASE = 1e18;\n\n    struct ScheduledDeposit {\n        uint16 updatedAtEpoch;\n        uint120 depositedAssets;\n        uint120 scheduledShares;\n    }\n    struct ScheduledWithdrawal {\n        uint16 updatedAtEpoch;\n        uint120 withdrawnShares;\n        uint120 scheduledAssets;\n    }\n\n    /// @notice Process scheduled deposits from previous epochs if any\n    /// @param scheduledDeposit_ instance of scheduled deposit\n    /// @param sharePriceByEpoch_ mapping that golds share prices by epoch IDs\n    /// @param currentEpochId_ current epoch ID\n    function processScheduledShares(\n        ScheduledDeposit memory scheduledDeposit_,\n        mapping(uint16 => uint256) storage sharePriceByEpoch_,\n        uint16 currentEpochId_\n    )\n        internal\n        view\n        returns (uint256 scheduledShares)\n    {\n        scheduledShares = scheduledDeposit_.scheduledShares;\n\n        // If there are deposited assets from previous epoch, calculate required shares\n        if (\n            scheduledDeposit_.updatedAtEpoch < currentEpochId_ &&\n            scheduledDeposit_.depositedAssets != 0\n        ) {\n            scheduledShares +=\n                (scheduledDeposit_.depositedAssets *\n                    sharePriceByEpoch_[scheduledDeposit_.updatedAtEpoch]) /\n                BASE;\n        }\n    }\n\n    /// @notice Process scheduled withdrawals from previous epochs if any\n    /// @param scheduledWithdrawal_ instance of scheduled withdrawal\n    /// @param sharePriceByEpoch_ mapping that golds share prices by epoch IDs\n    /// @param currentEpochId_ current epoch ID\n    function processScheduledAssets(\n        ScheduledWithdrawal memory scheduledWithdrawal_,\n        mapping(uint16 => uint256) storage sharePriceByEpoch_,\n        uint16 currentEpochId_\n    )\n        internal\n        view returns (uint256 scheduledAssets)\n    {\n        scheduledAssets = scheduledWithdrawal_.scheduledAssets;\n\n        // If there are withdrawn shares from previous epoch, calculate required assets\n        if (\n            scheduledWithdrawal_.updatedAtEpoch < currentEpochId_ &&\n            scheduledWithdrawal_.withdrawnShares != 0\n        ) {\n            scheduledAssets +=\n                (scheduledWithdrawal_.withdrawnShares * BASE) /\n                sharePriceByEpoch_[scheduledWithdrawal_.updatedAtEpoch];\n        }\n    }\n\n    function assertUint120(uint256 num) internal pure {\n        require(num <= type(uint120).max, \"SCH1\");\n    }\n}\n"
    },
    "contracts/utils/Selectors.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.0;\n\nlibrary Selectors {\n    bytes4 internal constant SAFE_SIGN_MESSAGE = bytes4(keccak256(bytes(\"signMessage(bytes)\")));\n\n    bytes4 internal constant ERC20_TRANSFER = bytes4(keccak256(bytes(\"transfer(address,uint256)\")));\n    bytes4 internal constant ERC20_APPROVE = bytes4(keccak256(bytes(\"approve(address,uint256)\")));\n}\n"
    },
    "opium-auction-v2/contracts/helpers/EIP712Alien.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712Alien {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n    address private immutable _ALIEN_ADDRESS;\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(address alien, string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n        _ALIEN_ADDRESS = alien;\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion, alien);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION, _ALIEN_ADDRESS);\n        }\n    }\n\n    function _buildDomainSeparator(bytes32 typeHash, bytes32 name, bytes32 version, address alien) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                typeHash,\n                name,\n                version,\n                block.chainid,\n                alien\n            )\n        );\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "opium-auction-v2/contracts/helpers/Types.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.9;\n\nlibrary Types {\n    struct StaticOrder {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;\n        uint256 makingAmount;\n        uint256 takingAmount;\n    }\n\n    struct Order {\n        uint256 salt;\n        address makerAsset;\n        address takerAsset;\n        address maker;\n        address receiver;\n        address allowedSender;\n        uint256 makingAmount;\n        uint256 takingAmount;\n        bytes makerAssetData;\n        bytes takerAssetData;\n        bytes getMakerAmount;\n        bytes getTakerAmount;\n        bytes predicate;\n        bytes permit;\n        bytes interaction;\n    }\n}\n"
    },
    "opium-auction-v2/contracts/utils/UsingLimitOrderProtocolV2.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/interfaces/IERC1271.sol\";\n\nimport \"../helpers/Types.sol\";\nimport \"../helpers/EIP712Alien.sol\";\n\nabstract contract UsingLimitOrderProtocolV2 is IERC1271, EIP712Alien {\n  bytes32 constant private _LIMIT_ORDER_TYPEHASH = keccak256(\n    \"Order(uint256 salt,address makerAsset,address takerAsset,address maker,address receiver,address allowedSender,uint256 makingAmount,uint256 takingAmount,bytes makerAssetData,bytes takerAssetData,bytes getMakerAmount,bytes getTakerAmount,bytes predicate,bytes permit,bytes interaction)\"\n  );\n\n  address public immutable limitOrderProtocol;\n\n  constructor(address limitOrderProtocol_) EIP712Alien(limitOrderProtocol_, \"1inch Limit Order Protocol\", \"2\") {\n    limitOrderProtocol = limitOrderProtocol_;\n  }\n\n  function isValidSignature(bytes32 hash, bytes memory signature) public view returns(bytes4) {\n    Types.Order memory order = abi.decode(signature, (Types.Order));\n\n    require(\n      hashOrder(order) == hash &&\n      _isValidOrder(order)\n    );\n\n    return this.isValidSignature.selector;\n  }\n\n  function _isValidOrder(Types.Order memory order_) internal view virtual returns (bool);\n\n  function hashOrder(Types.Order memory order) public view returns(bytes32) {\n    Types.StaticOrder memory staticOrder;\n    assembly {  // solhint-disable-line no-inline-assembly\n      staticOrder := order\n    }\n    return _hashTypedDataV4(\n      keccak256(\n        abi.encode(\n          _LIMIT_ORDER_TYPEHASH,\n          staticOrder,\n          keccak256(order.makerAssetData),\n          keccak256(order.takerAssetData),\n          keccak256(order.getMakerAmount),\n          keccak256(order.getTakerAmount),\n          keccak256(order.predicate),\n          keccak256(order.permit),\n          keccak256(order.interaction)\n        )\n      )\n    );\n  }\n}\n"
    },
    "opium-auction-v2/contracts/utils/UsingOpiumAuctionV2.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./UsingLimitOrderProtocolV2.sol\";\n\nabstract contract UsingOpiumAuctionV2 is UsingLimitOrderProtocolV2 {\n  address public immutable auctionHelperContract;\n\n  // Auction data\n  enum PricingFunction {\n    LINEAR,\n    EXPONENTIAL\n  }\n\n  enum PricingDirection {\n    INCREASING,\n    DECREASING\n  }\n  \n  struct AuctionOrder {\n    IERC20 sellingToken;\n    IERC20 purchasingToken;\n    uint256 sellingAmount;\n    PricingFunction pricingFunction;\n    uint256[] pricingFunctionParams;\n    PricingDirection pricingDirection;\n    bool partialFill;\n    uint256 minPurchasingAmount;\n    uint256 maxPurchasingAmount;\n    uint256 startedAt;\n    uint256 endedAt;\n    uint256 salt;\n  }\n\n  constructor(\n    address auctionHelperContract_,\n    address limitOrderProtocol_\n  ) UsingLimitOrderProtocolV2(limitOrderProtocol_) {\n    auctionHelperContract = auctionHelperContract_;\n  }\n\n  function auctionToLimitOrder(\n    AuctionOrder memory auctionOrder_\n  ) public view returns (Types.Order memory order) {\n    order.salt = auctionOrder_.salt;\n    order.makerAsset = address(auctionOrder_.sellingToken);\n    order.takerAsset = address(auctionOrder_.purchasingToken);\n    order.maker = address(this);\n    order.receiver = auctionHelperContract;\n    order.allowedSender = address(0x0000000000000000000000000000000000000000);\n    order.makingAmount = auctionOrder_.sellingAmount;\n    order.takingAmount = auctionOrder_.maxPurchasingAmount;\n    // Omit: order.makerAssetData;\n    // Omit: order.takerAssetData;\n    order.getMakerAmount = _prepareGetMakerAmount(auctionOrder_);\n    order.getTakerAmount = _prepareGetTakerAmount(auctionOrder_);\n    order.predicate = _preparePredicate(auctionOrder_);\n    // Omit: order.permit;\n    order.interaction = _prepareInteraction(auctionOrder_);\n  }\n\n  function _prepareGetMakerAmount(AuctionOrder memory auctionOrder_) internal view returns (bytes memory getMakerAmount) {\n    getMakerAmount = \n      auctionOrder_.pricingFunction == PricingFunction.LINEAR\n        ? abi.encodeWithSignature(\n            \"getLinearAuctionMakerAmount(uint256,uint256,uint256,uint256,uint256,bool,uint256)\",\n            auctionOrder_.sellingAmount,\n            auctionOrder_.maxPurchasingAmount,\n            auctionOrder_.minPurchasingAmount,\n            auctionOrder_.startedAt, \n            auctionOrder_.endedAt,\n            auctionOrder_.pricingDirection == PricingDirection.INCREASING,\n            0\n          )\n        : abi.encodeWithSignature(\n            \"getExponentialAuctionMakerAmount(uint256,uint256,uint256,uint256,uint256,bool,uint256,uint256)\",\n            auctionOrder_.sellingAmount,\n            auctionOrder_.maxPurchasingAmount,\n            auctionOrder_.minPurchasingAmount,\n            auctionOrder_.startedAt, \n            auctionOrder_.endedAt,\n            auctionOrder_.pricingDirection == PricingDirection.INCREASING,\n            auctionOrder_.pricingFunctionParams[0],\n            0\n          );\n\n    getMakerAmount = abi.encodeWithSignature(\"arbitraryStaticCall(address,bytes)\", auctionHelperContract, getMakerAmount);\n    \n    getMakerAmount = _slice(getMakerAmount, 0, getMakerAmount.length - 60);\n  }\n\n  function _prepareGetTakerAmount(AuctionOrder memory auctionOrder_) internal view returns (bytes memory getTakerAmount) {\n    getTakerAmount = \n      auctionOrder_.pricingFunction == PricingFunction.LINEAR\n        ? abi.encodeWithSignature(\n            \"getLinearAuctionTakerAmount(uint256,uint256,uint256,uint256,uint256,bool,uint256)\",\n            auctionOrder_.sellingAmount,\n            auctionOrder_.maxPurchasingAmount,\n            auctionOrder_.minPurchasingAmount,\n            auctionOrder_.startedAt, \n            auctionOrder_.endedAt,\n            auctionOrder_.pricingDirection == PricingDirection.INCREASING,\n            0\n          )\n        : abi.encodeWithSignature(\n            \"getExponentialAuctionTakerAmount(uint256,uint256,uint256,uint256,uint256,bool,uint256,uint256)\",\n            auctionOrder_.sellingAmount,\n            auctionOrder_.maxPurchasingAmount,\n            auctionOrder_.minPurchasingAmount,\n            auctionOrder_.startedAt, \n            auctionOrder_.endedAt,\n            auctionOrder_.pricingDirection == PricingDirection.INCREASING,\n            auctionOrder_.pricingFunctionParams[0],\n            0\n          );\n\n    getTakerAmount = abi.encodeWithSignature(\"arbitraryStaticCall(address,bytes)\", auctionHelperContract, getTakerAmount);\n\n    getTakerAmount = _slice(getTakerAmount, 0, getTakerAmount.length - 60);\n  }\n\n  function _preparePredicate(AuctionOrder memory auctionOrder_) internal view returns (bytes memory predicate) {\n    address[] memory addressArgs = new address[](2);\n    addressArgs[0] = auctionHelperContract;\n    addressArgs[1] = auctionHelperContract;\n\n    bytes[] memory bytesArgs = new bytes[](2);\n    bytesArgs[0] = abi.encodeWithSignature(\"nonceEquals(address,uint256)\", address(this), 0);\n    bytesArgs[1] = abi.encodeWithSignature(\"timestampBelow(uint256)\", auctionOrder_.endedAt);\n\n    predicate = abi.encodeWithSignature(\"and(address[],bytes[])\", addressArgs, bytesArgs);\n  }\n\n  function _prepareInteraction(AuctionOrder memory auctionOrder_) internal view returns (bytes memory interaction) {\n    bytes memory interactionData = abi.encode(\n      address(this),\n      !auctionOrder_.partialFill ? auctionOrder_.sellingAmount : 0,\n      auctionOrder_.startedAt\n    );\n\n    interaction = abi.encodePacked(auctionHelperContract, interactionData);\n  }\n\n  function _slice(\n    bytes memory _bytes,\n    uint256 _start,\n    uint256 _length\n  ) internal pure returns (bytes memory) {\n    require(_length + 31 >= _length, \"slice_overflow\");\n    require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n    bytes memory tempBytes;\n\n    assembly {\n      switch iszero(_length)\n      case 0 {\n        // Get a location of some free memory and store it in tempBytes as\n        // Solidity does for memory variables.\n        tempBytes := mload(0x40)\n\n        // The first word of the slice result is potentially a partial\n        // word read from the original array. To read it, we calculate\n        // the length of that partial word and start copying that many\n        // bytes into the array. The first word we copy will start with\n        // data we don't care about, but the last `lengthmod` bytes will\n        // land at the beginning of the contents of the new array. When\n        // we're done copying, we overwrite the full first word with\n        // the actual length of the slice.\n        let lengthmod := and(_length, 31)\n\n        // The multiplication in the next line is necessary\n        // because when slicing multiples of 32 bytes (lengthmod == 0)\n        // the following copy loop was copying the origin's length\n        // and then ending prematurely not copying everything it should.\n        let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n        let end := add(mc, _length)\n\n        for {\n          // The multiplication in the next line has the same exact purpose\n          // as the one above.\n          let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n        } lt(mc, end) {\n          mc := add(mc, 0x20)\n          cc := add(cc, 0x20)\n        } {\n          mstore(mc, mload(cc))\n        }\n\n        mstore(tempBytes, _length)\n\n        //update free-memory pointer\n        //allocating the array padded to 32 bytes like the compiler does now\n        mstore(0x40, and(add(mc, 31), not(31)))\n      }\n      //if we want a zero-length slice let's just return a zero-length array\n      default {\n        tempBytes := mload(0x40)\n        //zero out the 32 bytes slice we are about to return\n        //we need to do it because Solidity does not garbage collect\n        mstore(tempBytes, 0)\n\n        mstore(0x40, add(tempBytes, 0x20))\n      }\n    }\n\n    return tempBytes;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}